#!/usr/bin/env python3

import contextlib as __stickytape_contextlib


@__stickytape_contextlib.contextmanager
def __stickytape_temporary_dir():
    import tempfile
    import shutil
    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)


with __stickytape_temporary_dir() as __stickytape_working_dir:
    def __stickytape_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __stickytape_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    with open(os.path.join(partial_path, "__init__.py"), "wb") as f:
                        f.write(b"\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__stickytape_working_dir, path)
        with open(full_path, "wb") as module_file:
            module_file.write(contents)


    import sys as __stickytape_sys

    __stickytape_sys.path.insert(0, __stickytape_working_dir)

    __stickytape_write_module('script_skeleton.py',
                              b'#!/usr/bin/env python3\n\n# standard imports\nimport sys, traceback, os, requests, argparse, json, time, uuid, threading\nfrom akamai.edgegrid import EdgeGridAuth, EdgeRc\nfrom configparser import ConfigParser\nfrom urllib import parse\nfrom argparse import RawTextHelpFormatter\nfrom termcolor import colored\n\n# global variables, NOT thread safe for write operations\ng_input_args = None\ng_default_edgerc = os.path.expanduser(\'~/.edgerc\')\ng_default_section = os.path.expanduser(\'default\')\n\ng_api_client = None\ng_default_stderr = sys.stderr\ng_default_stdout = sys.stdout\ng_append_stderr = None\ng_append_stdout = None\ng_force_silent = False\ng_no_terminal_logging = False\ng_no_standard_output = False\ng_log_format = "json"\ng_logged_header = False\n\ng_run_id = str(uuid.uuid4())\ng_do_snore = 0 # toggles whether or not the app should being snoring audibly while idle\n\n\nclass UnicornException(Exception):\n    def __init__(self, error_message):\n        self.error_message = error_message\n        super().__init__(self.error_message)\n\n\ndef log(msg, log_level="INFO",event=""):\n    global g_append_stderr\n    global g_default_stderr\n    global g_force_silent\n    global g_no_terminal_logging\n    global g_log_format\n    global g_logged_header\n\n    json_output = {}\n    json_output["timestamp"] = time.time()\n    json_output["level"] = log_level\n    json_output["event"] = event\n    json_output["message"] = msg\n\n    result = json.dumps(json_output)\n    if g_log_format != "json":\n        result = ""\n        if not g_logged_header:\n            result += "TIMESTAMP       \\tLEVEL\\tEVENT\\tMESSAGE\\n"\n            g_logged_header = True\n        result += f"""{json_output["timestamp"]}\\t{json_output["level"]}\\t{json_output["event"]}\\t{json_output["message"]}""".replace("\\n","\\\\n")\n\n    if not g_force_silent and not g_no_terminal_logging:\n        print(colored(result,\'yellow\'), file=g_default_stderr)\n\n    if (g_append_stderr != None):\n        g_append_stderr.write(result)\n        g_append_stderr.write("\\n")\n        g_append_stderr.flush()\n\n\ndef output(msg):\n    global g_append_stdout\n    global g_append_stderr\n    global g_force_silent\n    global g_no_standard_output\n\n    if not g_force_silent and not g_no_standard_output:\n        print(colored(msg,\'white\'), file=g_default_stdout)\n\n    if (g_append_stdout != None):\n        g_append_stdout.write(msg)\n        g_append_stdout.write("\\n")\n        g_append_stdout.flush()\n\n\ndef log_generic_exception(log_level="ERROR"):\n    e = traceback.format_exc(limit=0)\n    log(msg=e, log_level="ERROR")\n\n\ndef die(msg,error_code=-1,log_level="INFO"):\n    \'\'\'Throws exception with helpful error message and numeric exit code available to the shell.\'\'\'\n    txt = ""\n    try:\n        raise UnicornException(error_message=msg)\n    except:\n        txt = traceback.format_exc(limit=0)\n        exc_type, exc_obj, exc_tb = sys.exc_info()\n        exc_file = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\n        log(msg= str(exc_type) + " / " + exc_file + " / line " + str(exc_tb.tb_lineno) + " / " + txt,\n            log_level=log_level,event="DIE:" + str(error_code));\n        sys.exit(error_code)\n\ndef start_snoring():\n    \'\'\'Crude progress indicator for long operations so that the user knows the script isn\'t just hanging.\'\'\'\n    global g_do_snore\n    if g_do_snore == 0:\n        g_do_snore = 1\n        t = threading.Thread(target=keep_snoring)\n        t.start()\n\ndef stop_snoring():\n    \'\'\'Crude progress indicator for long operations so that the user knows the script isn\'t just hanging.\'\'\'\n    global g_do_snore\n    if g_do_snore == 1:\n        g_do_snore = -1\n        while g_do_snore == -1:\n            time.sleep(1)\n        if not g_force_silent and not g_no_terminal_logging:\n            print("",file=g_default_stderr)\n            g_default_stderr.flush()\n\n\ndef keep_snoring():\n    \'\'\'Crude progress indicator for long operations so that the user knows the script isn\'t just hanging.\'\'\'\n    global g_do_snore\n    global g_force_silent\n    global g_no_terminal_logging\n    while g_do_snore == 1:\n        if not g_force_silent and not g_no_terminal_logging:\n            print(colored(".",\'yellow\'),file=g_default_stderr,end="")\n            g_default_stderr.flush()\n        time.sleep(1)\n    if g_do_snore != 1:\n        g_do_snore = 0\n\nclass SimpleEdgeGridHttpCaller:\n    \'\'\'Minimal class for calling Akamai APIs\'\'\'\n\n    def __init__(self, session, baseurl):\n        self.session = session\n        self.baseurl = baseurl\n        return None\n\n    def urlJoin(self, url, path):\n        return parse.urljoin(url, path)\n    urlJoin = staticmethod(urlJoin)\n\n    def doGet(self, endpoint, parameters=None,headers=None):\n        path = endpoint\n        endpoint_result = None\n        try:\n            endpoint_result = self.session.get(parse.urljoin(self.baseurl, path), headers=headers, params=parameters);\n            self.last_status_code = endpoint_result.status_code\n            self.last_endpoint_result = endpoint_result\n        except:\n            log_generic_exception()\n            endpoint_result = None\n            self.last_status_code = -1\n            self.last_endpoint_result = endpoint_result\n        return endpoint_result\n\n    def getXMLResult(self, endpoint, parameters=None):\n        headers = {\'Accept\': \'text/xml\'}\n        return self.doGet(endpoint, parameters, headers).text\n\n    def getJSONResult(self, endpoint, parameters=None):\n        headers = {\'Accept\': \'application/json\'}\n        return self.doGet(endpoint, parameters, headers).json()\n\n    def doPost(self, endpoint, parameters=None,headers=None,payload=None):\n        path = endpoint\n        endpoint_result = None\n        try:\n            endpoint_result = self.session.post(parse.urljoin(self.baseurl, path), json=payload, headers=headers,\n                                                params=parameters);\n            self.last_status_code = endpoint_result.status_code\n            self.last_endpoint_result = endpoint_result\n        except:\n            log_generic_exception()\n            endpoint_result = None\n            self.last_status_code = -1\n            self.last_endpoint_result = endpoint_result\n        return endpoint_result\n\n    def postAcceptingJSON(self, endpoint, parameters=None, payload=None):\n        headers = {\'Accept\': \'application/json\'}\n        return self.doPost(endpoint, parameters, headers, payload).json()\n\n    def doDelete(self, endpoint, parameters=None,headers=None,payload=None):\n        path = endpoint\n        endpoint_result = None\n        try:\n            endpoint_result = self.session.delete(parse.urljoin(self.baseurl, path), json=payload, headers=headers,\n                                                  params=parameters);\n            self.last_status_code = endpoint_result.status_code\n            self.last_endpoint_result = endpoint_result\n        except:\n            log_generic_exception()\n            endpoint_result = None\n            self.last_status_code = -1\n            self.last_endpoint_result = endpoint_result\n        return endpoint_result\n\n    def deleteAcceptingJSON(self, endpoint, parameters=None, payload=None):\n        headers = {\'Accept\': \'application/json\'}\n        return self.doDelete(endpoint, parameters, headers, payload).json()\n\n    def put(self, endpoint, parameters=None,headers=None,payload=None):\n        path = endpoint\n        endpoint_result = None\n        try:\n            endpoint_result = self.session.put(parse.urljoin(self.baseurl, path), json=data, headers=headers,\n                                               params=parameters);\n            self.last_status_code = endpoint_result.status_code\n            self.last_endpoint_result = endpoint_result\n        except:\n            log_generic_exception()\n            endpoint_result = None\n            self.last_status_code = -1\n            self.last_endpoint_result = endpoint_result\n        return endpoint_result\n\n\nclass ApiArguments:\n    \'\'\'Simple class for handling script arguments\'\'\'\n\n    def __init__(self, short_description, epilog=None, additional_args=None):\n        self.parser = argparse.ArgumentParser(description=short_description, epilog=epilog,\n                                              formatter_class=RawTextHelpFormatter, allow_abbrev=False)\n\n        #optional arguments with defaults\n        self.parser.add_argument("--section", required=False, help="override default .edgerc section", action="store",\n                                 dest="section")\n        self.parser.add_argument("--edgerc", required=False, help="override default .edgerc file path", action="store",\n                                 dest="edgerc")\n        self.parser.add_argument("--runId", required=False, help="ADVANCED: force specific id number for this session",\n                                 action="store", dest="runid")\n        self.parser.add_argument("--sessionLogging", required=False, help="add unique id to log file name",\n                                 action="store_true", dest="sessionlogging")\n        self.parser.add_argument("--silentTerminal", required=False, help="no output to stdout or stderr",\n                                 action="store_true", dest="silent")\n\n        self.parser.add_argument("--suppressTerminalLogging", help="do not echo the stderr log to the terminal",\n                                 action="store_true", dest="suppressterminallogging")\n\n        self.parser.add_argument("--suppressStandardOutput", help="do not print anything to stdout",\n                                 action="store_true", dest="suppressstandardoutput")\n\n        self.log_mode = self.parser.add_mutually_exclusive_group(required=True)\n        self.log_mode.add_argument("--suppressFileLogging", help="do not write to log file ", action="store_true",\n                                   dest="suppressfilelogging")\n        self.log_mode.add_argument("--logDirectory", help="log directory", action="store", dest="logdirectory")\n\n        self.parser.add_argument("--logFormat", choices=["json","text"], required=False,\n                                 help="log output format, \\"json\\" or \\"text\\"", action="store",\n                                 dest="logformat", default="json")\n\n        self.parser.add_argument("--switchKey", required=False,\n                                 help="account switch key, default value = \\"NOT-ENTERED\\"", action="store",\n                                 dest="switch_key", default="NOT-ENTERED")\n\n        #arguments added at runtime\n        if (additional_args):\n            for additional_arg in additional_args:\n                self.parser.add_argument("--"+additional_arg["keyword"], required=additional_arg["required"],\n                                         help=additional_arg["help"], action=additional_arg["action"],\n                                         dest=additional_arg["dest"])\n\n        self.parse_args()\n\n    def parse_args(self):\n        global g_default_edgerc\n        global g_default_section\n        global g_log_format\n\n        self.args, self.unknown = self.parser.parse_known_args()\n\n        self.section = g_default_section if not self.args.section else self.args.section\n        self.edgerc = g_default_edgerc if not self.args.edgerc else self.args.edgerc\n        self.switch_key = None if not self.args.switch_key else self.args.switch_key\n\n        global g_force_silent\n        if self.args.silent and self.args.suppressfilelogging:\n            g_force_silent = False\n            die("You are trying to apply --silentTerminal and --suppressFileLogging on the same session.  That is pure "\n                "madness and it is not allowed.")\n\n        if self.args.suppressterminallogging and self.args.suppressfilelogging:\n            g_force_silent = False\n            die("You are trying to apply --suppressTerminalLogging and --suppressFileLogging on the same session.  That"\n                " is exactly the sort of city-slicker shenanigan my mama warned me about and it is not allowed.")\n\n\n        if self.section:\n            if "\\"" in self.section or "\\n" in self.section or "\\r" in self.section:\n                die("--section argument must not contain special characters.")\n\n        g_log_format = self.args.logformat\n\n\nclass SimpleEdgeGridConfig:\n    \'\'\'Minimal class for HTTP API authentication\'\'\'\n    arguments = {}\n    def __init__(self, edgerc=g_default_edgerc, section=g_default_section ):\n\n        config_file = edgerc\n\n        if os.path.isfile(config_file):\n            config = ConfigParser()\n            config.read_file(open(config_file))\n            if not config.has_section(section):\n                err_msg = "ERROR: No section named %s was found in your %s file\\n" % (section, config_file)\n                die(err_msg)\n            for key, value in config.items(section):\n                # ConfigParser lowercases magically\n                if key not in self.arguments or self.arguments[key] == None:\n                    self.arguments[key] = value\n        else:\n            err_msg = ".edgerc configuration file not found at path: " + config_file\n            die(err_msg)\n\n        for option in self.arguments:\n            setattr(self, option, self.arguments[option])\n\n        self.create_base_url()\n\n    def create_base_url(self):\n        self.base_url = "https://%s" % self.host\n\n\nclass ApiClient:\n    \'\'\'Simple class that loads credentials and calls web services\'\'\'\n\n    def get_last_response_code(self):\n        return self.httpCaller.last_status_code\n\n    def get_last_endpoint_result(self):\n        return self.httpCaller.last_endpoint_result\n\n    def __init__(self, edgerc=os.path.expanduser(\'~/.edgerc\'), section="default", switch_key=None):\n        self.session = requests.Session()\n        self.current_switch_key = None\n        self.refresh(edgerc,section,switch_key)\n\n    def update_parameters(self,switch_key=None):\n        if switch_key != None:\n            self.current_switch_key = switch_key\n\n    def refresh(self, edgerc=os.path.expanduser(\'~/.edgerc\'), section="default", switch_key=None):\n        self.current_edgerc = edgerc\n        self.current_section = section\n        self.config = SimpleEdgeGridConfig(edgerc=self.current_edgerc,section=self.current_section)\n        self.session.auth = EdgeGridAuth(client_token=self.config.client_token, client_secret=self.config.client_secret,\n                                access_token=self.config.access_token)\n        self.baseurl = \'%s://%s/\' % (\'https\', self.config.host)\n        self.httpCaller = SimpleEdgeGridHttpCaller(self.session, self.baseurl)\n        self.update_parameters(switch_key=switch_key)\n\n\ndef set_api_client(c):\n    global g_api_client\n    g_api_client = c\n\n\ndef get_api_client():\n    global g_api_client\n    return g_api_client\n\n\ndef set_input_args(a):\n    global g_input_args\n    g_input_args = a\n\n\ndef get_input_args():\n    global g_input_args\n    return g_input_args\n\n\ndef set_run_id(id):\n    global g_run_id\n    g_run_id = id\n\n\ndef get_run_id():\n    global g_run_id\n    return g_run_id\n\n\ndef set_app_name(str):\n    global g_app_name\n    g_app_name = str\n\n\ndef set_std_files(err, out):\n    global g_append_stderr\n    global g_append_stdout\n    g_append_stderr = err\n    g_append_stdout = out\n\n\ndef get_app_name():\n    global g_app_name\n    return g_app_name\n\ndef execute_main_method(main_module):\n    application_name = None\n    if (hasattr(main_module, "application_name")):\n        application_name = getattr(main_module, "application_name")\n        application_name = \'\'.join(e for e in application_name if (e.isalnum() or e == \'-\'))\n    else:\n        die("application_name not found.")\n\n    if (hasattr(main_module, "main_method")):\n        m = getattr(main_module, "main_method")\n        relaunch_arguments = None\n        try:\n            additional_args = None\n            if (hasattr(main_module, "additional_arguments")):\n                additional_args = getattr(main_module, "additional_arguments")()\n            initialize(application_name,additional_args=additional_args)\n            relaunch_arguments = m()\n\n        except UnicornException as se:\n            die("Graceful exit.", error_code=0)\n        except SystemExit:\n            # probably the argument parsing failed, print the protip to assist the poor end user\n            if not get_input_args():\n                if (hasattr(main_module, "application_protip")):\n                    print(colored(str(getattr(main_module, "application_protip")),\'yellow\'), file=g_default_stderr)\n            else:\n                # otherwise the die() method was called and the message was already printed.  No need to print anything\n                ignore_this_exception = True\n        except:\n            die("Fatal error.", error_code=-1)\n        finally:\n            cleanup()\n            if relaunch_arguments:\n                os.execv(sys.argv[0], sys.argv)\n\n    else:\n        die("main_method not found.")\n\ndef get_account_properties(contract_id, group_id):\n    parameters = {\'accountSwitchKey\': get_api_client().current_switch_key, \'groupId\' : group_id,\n                  \'contractId\': contract_id}\n    json_data = get_api_client().httpCaller.getJSONResult(\'/papi/v1/properties\', parameters)\n    if get_api_client().get_last_response_code() != 200:\n        raise UnicornException(error_message=json.dumps(json_data));\n    return json_data\n\ndef get_account_property_versions(property_id):\n    parameters = {\'accountSwitchKey\': get_api_client().current_switch_key}\n    json_data = get_api_client().httpCaller.getJSONResult(f\'/papi/v1/properties/{property_id}/versions\', parameters)\n    if get_api_client().get_last_response_code() != 200:\n        raise UnicornException(error_message=json.dumps(json_data));\n    return json_data\n\ndef get_property_xml(contract_id, group_id,property_id,version_id):\n    parameters = {\'accountSwitchKey\': get_api_client().current_switch_key, \'groupId\' : group_id,\n                  \'contractId\': contract_id}\n    xml_data = get_api_client().httpCaller.getXMLResult(\'/papi/v1/properties/%s/versions/%s\' %\n                                                        (property_id, version_id), parameters)\n    if get_api_client().get_last_response_code() != 200:\n        raise UnicornException(error_message=xml_data);\n    return xml_data\n\n    xml_data = get_api_client().httpCaller.getXMLResult(\'/papi/v1/properties/%s/versions/%s\' % (propertyId, versionId), parameters)\n    if get_api_client().get_last_response_code() == 200:\n        pprint.pprint(xml_data);\n        return xml_data;\n\n\ndef get_account_groups():\n    parameters = {\'accountSwitchKey\': get_api_client().current_switch_key}\n    json_data = get_api_client().httpCaller.getJSONResult(\'/papi/v1/groups\', parameters)\n    if get_api_client().get_last_response_code() != 200:\n        raise UnicornException(error_message=json.dumps(json_data));\n    return json_data\n\n\ndef get_account_contracts():\n    parameters = {\'accountSwitchKey\': get_api_client().current_switch_key}\n    json_data = get_api_client().httpCaller.getJSONResult(\'/papi/v1/contracts\', parameters)\n    if get_api_client().get_last_response_code() != 200:\n        raise UnicornException(error_message=json.dumps(json_data));\n    return json_data\n\n\ndef get_open_identity_id():\n    endpoint = f"""/identity-management/v1/open-identities/tokens/{get_api_client().config.arguments["access_token"]}"""\n    json_data = get_api_client().httpCaller.getJSONResult(endpoint)\n    if get_api_client().get_last_response_code() != 200:\n        raise UnicornException(error_message=json.dumps(json_data));\n    else:\n        return json_data["identity"]["openIdentityId"]\n\n\ndef get_account_switch_keys_from_search(identity, search=""):\n    endpoint = f"/identity-management/v1/open-identities/{identity}/account-switch-keys?search={search}"\n    json_data = get_api_client().httpCaller.getJSONResult(endpoint)\n    if get_api_client().get_last_response_code() != 200:\n        raise UnicornException(error_message=json.dumps(json_data));\n    else:\n        return json_data\n\ndef do_purge(tags):\n    network = "production"\n    endpoint = \'/ccu/v3/delete/tag/{}\'.format(network)\n    payload = {\n        "objects": tags\n    }\n    json_data = get_api_client().httpCaller.postAcceptingJSON(endpoint,payload=payload)\n    if get_api_client().get_last_response_code() != 200:\n        raise UnicornException(error_message=json.dumps(json_data));\n    else:\n        return json_data\n\n\ndef search(api_id, value):\n    \'\'\'Search for Account Switch Key\'\'\'\n\n    endpoint = "/identity-management/v1/open-identities/"+api_id+"/account-switch-keys?search="+value\n    data = ""\n\n    result = make_request("get", endpoint, data)\n\n    print("{:25} {:40}".format("Switch Key", "Account Name"))\n    print("{:25} {:40}".format("---", "---"))\n    for items in result.json():\n        print("{:25} {:40}".format(items["accountSwitchKey"], items["accountName"]))\n\n    print(\'\\n\')\n\n\ndef initialize(app_name,additional_args=None):\n    global g_log_format\n\n    set_app_name(app_name)\n    # we need to check sys.argv directly so that we can log errors properly if they occur before parsing args\n    if \'--logFormat\' in sys.argv:\n        if (len(sys.argv) > (sys.argv.index(\'--logFormat\')+1)):\n            if sys.argv[sys.argv.index(\'--logFormat\') + 1] == "text":\n                g_log_format = "text"\n\n    if \'--runId\' in sys.argv:\n        if (len(sys.argv) > (sys.argv.index(\'--runId\') + 1)):\n            set_run_id(\'\'.join(e for e in sys.argv[sys.argv.index(\'--runId\') + 1] if (e.isalnum() or e == \'-\')))\n\n    if \'--logDirectory\' in sys.argv:\n        if (len(sys.argv) > (sys.argv.index(\'--logDirectory\')+1)):\n            err_log_path = (sys.argv[sys.argv.index(\'--logDirectory\') + 1]) + \'/\' + get_app_name() + \'.stderr.log\'\n            out_log_path = (sys.argv[sys.argv.index(\'--logDirectory\') + 1]) + \'/\' + get_app_name() + \'.stdout.log\'\n\n            if \'--sessionLogging\' in sys.argv:\n                err_log_path = (sys.argv[sys.argv.index(\'--logDirectory\') + 1]) + \'/\' + get_app_name() + \'.\' + \\\n                               get_run_id() + \'.stderr.log\'\n                out_log_path = (sys.argv[sys.argv.index(\'--logDirectory\') + 1]) + \'/\' + get_app_name() + \'.\' + \\\n                               get_run_id() + \'.stdout.log\'\n\n            stderr_file = open(err_log_path, "a+")\n            stdout_file = open(out_log_path, "a+")\n\n            set_std_files(err=stderr_file,out=stdout_file)\n\n    args = ApiArguments(__doc__,additional_args=additional_args)\n    set_input_args(args)\n\n    global g_force_silent\n    g_force_silent = get_input_args().args.silent\n\n    global g_no_terminal_logging\n    g_no_terminal_logging = get_input_args().args.suppressterminallogging\n\n    global g_no_standard_output\n    g_no_standard_output = get_input_args().args.suppressstandardoutput\n\n    set_api_client(ApiClient(switch_key=get_input_args().switch_key, edgerc=get_input_args().edgerc,\n                                       section=get_input_args().section))\n\ndef cleanup():\n    global g_append_stderr\n    global g_append_stdout\n    if g_append_stderr != None:\n        g_append_stderr.close()\n    if g_append_stdout != None:\n        g_append_stdout.close()\n    stop_snoring()\n\n\ndef main_method():\n    log("Testing unicorn-skeleton functions...")\n    test_switch_key = "B-F-JOGS33"\n    log(f"Overriding switchKey to {test_switch_key} for testing purposes.")\n    get_api_client().update_parameters(switch_key=test_switch_key)\n    output(json.dumps(getAccountGroups()))\n\n\n# do not edit below this line.\napplication_name = "unicorn-skeleton-test"\napplication_protip = f"\\nSample command that tests this module with no file logging:\\n{sys.argv[0]} " \\\n                     f"--suppressFileLogging\\n"\nthis_module = sys.modules[__name__]\nif __name__ == "__main__":\n    execute_main_method(this_module)')
    # !/usr/bin/env python3
    import sys
    import script_skeleton
    import json

    # brief name of the application, alphanums and - only, this will be used in a file name, other chars will be removed.
    application_name = "do-purge"
    application_protip = f"\nSample syntax: {sys.argv[0]} --suppressFileLogging --switchKey B-F-JOGS33\n"

    # a few useful shorthand method aliases
    log = script_skeleton.log
    print = script_skeleton.output
    UnicornException = script_skeleton.UnicornException


    # customize main_method to code the main behavior below.  it will be automatically called when this module is run.
    def main_method():
        try:
            tags = script_skeleton.get_input_args().args.tag.split("#");
            purge_result = script_skeleton.do_purge(tags);
            print(json.dumps(purge_result))
        except UnicornException as ue:
            log(msg="Error occurred while trying to call do_purge: " + str(ue), log_level="ERROR")


    # customize additional_arguments to add command line switches that are not built in.
    def additional_arguments():
        arg_list = []

        arg = {}
        arg["keyword"] = "tag";
        arg["required"] = True;
        arg["help"] = "tag to purge";
        arg["action"] = "store";
        arg["dest"] = "tag";
        arg_list.append(arg)

        return arg_list


    # do not edit below this line.
    this_module = sys.modules[__name__]
    if __name__ == "__main__":
        script_skeleton.execute_main_method(this_module)
