#!/usr/bin/env python3

import contextlib as __stickytape_contextlib

@__stickytape_contextlib.contextmanager
def __stickytape_temporary_dir():
    import tempfile
    import shutil
    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)

with __stickytape_temporary_dir() as __stickytape_working_dir:
    def __stickytape_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __stickytape_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    with open(os.path.join(partial_path, "__init__.py"), "wb") as f:
                        f.write(b"\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__stickytape_working_dir, path)
        with open(full_path, "wb") as module_file:
            module_file.write(contents)

    import sys as __stickytape_sys
    __stickytape_sys.path.insert(0, __stickytape_working_dir)

    __stickytape_write_module('util.py', b'#standard imports\nimport sys, traceback, threading, time, urllib, os, requests, argparse, hashlib, pprint\nfrom termcolor import colored\nfrom akamai.edgegrid import EdgeGridAuth, EdgeRc\nfrom configparser import ConfigParser\nfrom urllib import parse\n\n#global variables, NOT thread safe\ndo_snore = 0                            #toggles whether or not the app should being snoring audibly while idle\ndefault_verbosity = 0                   #toggles detail level of debug messages\npristine_hashlib = hashlib.sha256()     #for checking the integrity of data and detecting updates\ndefault_edgerc = os.path.expanduser(\'~/.edgerc\')\ndefault_section = os.path.expanduser(\'default\')\napi_client = None\ninput_args = None\n\n#internal module error codes, use only negative integers\nerr_internal = [-1,"Internal error."]\n\ndef set_default_verbosity(v):\n    \'\'\'Set to -1 for silence, 0 for minimal error messages, 1 for detailed messages; -2 is a special value, do not use it\'\'\'\n    if v == -2:\n        die(err_internal[0],\'Never set verbosity to -2\')\n    global default_verbosity\n    default_verbosity = v\n\ndef get_default_verbosity():\n    \'\'\'Access the current verbosity value\'\'\'\n    global default_verbosity\n    return default_verbosity\n\ndef print_err(str, verbosity = -2, color=\'default\'):\n    \'\'\'Helper function prints to stderr if verbosity is >= 0 \'\'\'\n    if verbosity == -2:\n        verbosity = get_default_verbosity()\n    if verbosity >= 0:\n        if (color == \'default\'):\n            print (str, file=sys.stderr, end = \'\')\n        else:\n            print (colored(str,color), file=sys.stderr, end = \'\')\n        sys.stderr.flush()\n\ndef pprint_err(obj, verbosity = -2, color=\'default\'):\n    print_err(pprint.pformat(obj),verbosity,color)\n\ndef die(error, msg, verbosity=-2):\n    \'\'\'Throws exception with helpful error message and numeric exit code available to the shell.  If verbosity is 0, suppress the stack trace.  If verbosity < 0, print no information, only return exit code.\'\'\'\n    if verbosity == -2:\n        verbosity = get_default_verbosity()\n    try:\n        raise Exception(msg)\n    except:\n        exc_type, exc_value, exc_traceback = sys.exc_info()\n        if verbosity == 0:\n            traceback.print_exception(exc_type,exc_value,None,limit=0, file=sys.stderr)\n        else:\n            if verbosity > 0:\n                traceback.print_exc(file=sys.stderr)\n        sys.exit(error)\n\ndef start_snoring():\n    \'\'\'Crude progress indicator for long operations so that the user knows the script isn\'t just hanging.\'\'\'\n    global do_snore\n    if do_snore == 0:\n        do_snore = 1\n        t = threading.Thread(target=keep_snoring)\n        t.start()\n\ndef stop_snoring():\n    \'\'\'Crude progress indicator for long operations so that the user knows the script isn\'t just hanging.\'\'\'\n    global do_snore\n    if do_snore == 1:\n        do_snore = -1\n        while do_snore == -1:\n            time.sleep(1)\n\ndef keep_snoring():\n    \'\'\'Crude progress indicator for long operations so that the user knows the script isn\'t just hanging.\'\'\'\n    global do_snore\n    while do_snore == 1:\n        print_err(".",get_default_verbosity(),\'yellow\')\n        time.sleep(1)\n    if do_snore != 1:\n        do_snore = 0\n\ndef is_snoring():\n    \'\'\'Crude progress indicator for long operations so that the user knows the script isn\'t just hanging.\'\'\'\n    global do_snore\n    return do_snore\n\ndef cleanup():\n    \'\'\'Snip any loose threads before exiting\'\'\'\n    stop_snoring()\n\ndef seed_pristine_hashlib(seed):\n    \'\'\'use this function once at the beginning of execution to consistently salt the hashes generated by this library\'\'\'\n    pristine_hashlib.update(seed.encode())\n\ndef get_persistent_hex_digest(data):\n    \'\'\'retrieve an md5 hash without modifying the hashlib that generated it\'\'\'\n    sprout = pristine_hashlib.copy()\n    sprout.update(data.encode())\n    return sprout.hexdigest()\n\nclass SimpleEdgeGridHttpCaller:\n    \'\'\'Minimal class for calling Akamai APIs\'\'\'\n\n    def __init__(self, session, baseurl):\n        self.session = session\n        self.baseurl = baseurl\n        return None\n\n    def urlJoin(self, url, path):\n        return parse.urljoin(url, path)\n\n    def doGet(self, endpoint, parameters=None,headers=None):\n        path = endpoint\n        endpoint_result = None\n        while endpoint_result == None:\n            try:\n                endpoint_result = self.session.get(parse.urljoin(self.baseurl, path), headers=headers, params=parameters)\n            except:\n                print_err("Exception while calling web service!  Pausing 5 seconds and trying again...",color="red")\n                time.sleep(5)\n                endpoint_result = None\n        self.last_status_code = endpoint_result.status_code\n        self.last_endpoint_result = endpoint_result\n        return endpoint_result\n\n    def getXMLResult(self, endpoint, parameters=None):\n        headers = {\'Accept\': \'text/xml\'}\n        return self.doGet(endpoint, parameters, headers).text\n\n    def getJSONResult(self, endpoint, parameters=None):\n        headers = {\'Accept\': \'application/json\'}\n        return self.doGet(endpoint, parameters, headers).json()\n\n    def doPost(self, endpoint, parameters=None,headers=None,payload=None):\n        path = endpoint\n        endpoint_result = None\n        while endpoint_result == None:\n            try:\n                endpoint_result = self.session.post(parse.urljoin(self.baseurl, path), json=payload, headers=headers, params=parameters);\n            except:\n                print_err("Exception while calling web service!  Pausing 5 seconds and trying again...", color="red")\n                time.sleep(5)\n                endpoint_result = None\n        self.last_status_code = endpoint_result.status_code\n        self.last_endpoint_result = endpoint_result\n        return endpoint_result\n\n    def postAcceptingJSON(self, endpoint, parameters=None, payload=None):\n        headers = {\'Accept\': \'application/json\'}\n        return self.doPost(endpoint, parameters, headers, payload).json()\n\n    def doDelete(self, endpoint, parameters=None,headers=None,payload=None):\n        path = endpoint\n        endpoint_result = None\n        while endpoint_result == None:\n            try:\n                endpoint_result = self.session.delete(parse.urljoin(self.baseurl, path), json=payload, headers=headers, params=parameters);\n            except:\n                print_err("Exception while calling web service!  Pausing 5 seconds and trying again...", color="red")\n                time.sleep(5)\n                endpoint_result = None\n        self.last_status_code = endpoint_result.status_code\n        self.last_endpoint_result = endpoint_result\n        return endpoint_result\n\n    def deleteAcceptingJSON(self, endpoint, parameters=None, payload=None):\n        headers = {\'Accept\': \'application/json\'}\n        return self.doDelete(endpoint, parameters, headers, payload).json()\n\n    def put(self, endpoint, parameters=None,headers=None,payload=None):\n        path = endpoint\n\n        endpoint_result = None\n        while endpoint_result == None:\n            try:\n                endpoint_result = self.session.put(parse.urljoin(self.baseurl, path), data=payload, headers=headers, params=parameters);\n            except:\n                print_err("Exception while calling web service!  Pausing 5 seconds and trying again...", color="red")\n                time.sleep(5)\n                endpoint_result = None\n\n        self.last_status_code = endpoint_result.status_code\n        return endpoint_result\n\nclass ApiArguments:\n    \'\'\'Simple class for handling script arguments\'\'\'\n\n    def __init__(self, short_description, standard_arguments=True, autoparse=True):\n        self.parser = argparse.ArgumentParser(description=short_description)\n        if standard_arguments:\n            # Override default section in .edgerc\n            self.parser.add_argument("--section", required=False, help="override default .edgerc section", action="store", dest="section")\n            self.parser.add_argument("--edgerc", required=False, help="override default .edgerc file path", action="store", dest="edgerc")\n\n            self.debug_flags = self.parser.add_mutually_exclusive_group()\n            self.debug_flags.add_argument("-D", "--debug", help="verbose error output", action="store_true", dest="debug")\n            self.debug_flags.add_argument("-S", "--silent", help="suppress all error output", action="store_true", dest="silent")\n            self.debug_flags.add_argument("-X", "--explain", help="provide a detailed explanation of the supplied \'cmd\'", action="store_true", dest="explain")\n\n            self.required_args = self.parser.add_argument_group(\'required arguments\')\n\n            self.switchkeyarg = self.required_args.add_argument("--switchKey", required=False, help="account switchkey", action="store", dest="switchkey", default="")\n\n            if autoparse == True:\n                self.parse_args()\n\n    def parse_args(self):\n            self.args, self.unknown = self.parser.parse_known_args()\n            if self.args.debug:\n                set_default_verbosity(1)\n            if self.args.silent:\n                set_default_verbosity(-1)\n            self.section = default_section if not self.args.section else self.args.section\n            self.edgerc = default_edgerc if not self.args.edgerc else self.args.edgerc\n            self.switchkey = None if not self.args.switchkey else self.args.switchkey\n\n            if self.section:\n                if "\\"" in self.section or "\\n" in self.section or "\\r" in self.section:\n                    die(ERR_InternalError,"--section argument must not contain special characters.")\n\nclass SimpleEdgeGridConfig:\n    \'\'\'Minimal class for HTTP API authentication\'\'\'\n\n    def __init__(self, edgerc=default_edgerc, section=default_section ):\n\n        arguments = {}\n\n        config_file = edgerc\n\n        if os.path.isfile(config_file):\n            config = ConfigParser()\n            config.read_file(open(config_file))\n            if not config.has_section(section):\n                err_msg = "ERROR: No section named %s was found in your %s file\\n" % (section, config_file)\n                die(err_internal[0], err_msg)\n            for key, value in config.items(section):\n                # ConfigParser lowercases magically\n                if key not in arguments or arguments[key] == None:\n                    arguments[key] = value\n        else:\n            err_msg = ".edgerc configuration file not found at path: " + config_file\n            die(err_internal[0], err_msg)\n\n        for option in arguments:\n            setattr(self, option, arguments[option])\n\n        self.create_base_url()\n\n    def create_base_url(self):\n        self.base_url = "https://%s" % self.host\n\nclass ApiClient:\n    \'\'\'Simple class that loads credentials and calls web services\'\'\'\n\n    def get_last_response_code(self):\n        return self.httpCaller.last_status_code\n\n    def get_last_endpoint_result(self):\n        return self.httpCaller.last_endpoint_result\n\n    def __init__(self, edgerc=os.path.expanduser(\'~/.edgerc\'), section="default", switchkey=None):\n        self.session = requests.Session()\n        self.current_switchkey = None\n        self.refresh(edgerc,section,switchkey)\n\n    def update_parameters(self,switchkey=None):\n        if switchkey != None:\n            self.current_switchkey = switchkey\n\n    def refresh(self, edgerc=os.path.expanduser(\'~/.edgerc\'), section="default", switchkey=None):\n        self.current_edgerc = edgerc\n        self.current_section = section\n        self.config = SimpleEdgeGridConfig(edgerc=self.current_edgerc,section=self.current_section)\n        self.session.auth = EdgeGridAuth(client_token=self.config.client_token, client_secret=self.config.client_secret,\n                                access_token=self.config.access_token)\n        self.baseurl = \'%s://%s/\' % (\'https\', self.config.host)\n        self.httpCaller = SimpleEdgeGridHttpCaller(self.session, self.baseurl)\n        self.update_parameters(switchkey=switchkey)\n\ndef set_api_client(c):\n    global api_client\n    api_client = c\n\ndef get_api_client():\n    global api_client\n    return api_client\n\ndef set_input_args(a):\n    global input_args\n    input_args = a\n\ndef get_input_args():\n    global input_args\n    return input_args\n')
    __stickytape_write_module('gui.py', b'import util, wx, time, threading, pprint, os, urllib\nfrom util import get_api_client, get_input_args, print_err, pprint_err\nfrom subprocess import Popen, PIPE\n\ngoatc_buttons = []\nproperty_dialog = None\nlistbox_groupid = None\nlabel_groupid = None\nlabel_populatedgroupid = None\nlistbox_populatedgroupid_locked = False\nlistbox_propertyid = None\nlabel_populatedpropertyid = None\nlistbox_populatedpropertyid_locked = False\n\n\nclass SelectPropertyDialog(wx.Dialog):\n    def go(self, flag):\n        if (flag == False):\n            self.Close()\n        else:\n            wx.MessageBox("Wait for the current operation to complete before continuing.")\n\n    def __init__(self):\n        wx.Dialog.__init__(self, None, title="Select Other Property",style=(~wx.CLOSE_BOX))\n        self.SetSize(size=(400,400))\n        other_hidden_label = wx.StaticText(self, label="", pos=(0, 0))\n        other_hidden_label.Hide()\n        groupbtn = wx.Button(self, label="Get Group IDs", pos=(275,10))\n        groupbtn.Bind(wx.EVT_BUTTON, populate_group_id_nonblocking)\n\n        global txtctrl_switchkey\n        label_currentkey = wx.StaticText(self, label="Current Switch Key: " + txtctrl_switchkey.GetValue(), pos=(10, 10))\n        global label_populatedgroupid\n        label_populatedgroupid = wx.StaticText(self, label="", pos=(10, 16))\n        global listbox_populatedgroupid_locked\n\n        label_getproperties = wx.StaticText(self, label="Property ID List:", pos=(10, 185))\n        global label_populatedpropertyid\n        label_populatedpropertyid = wx.StaticText(self, label="...", pos=(10, 190))\n        global listbox_populatedpropertyid_locked\n        propertybtn = wx.Button(self, label="Get Property IDs", pos=(265,185))\n        global listbox_propertyid\n        listbox_propertyid = wx.ListBox(self, pos=(10, 205), size=(375,150))\n        propertybtn.Bind(wx.EVT_BUTTON, populate_property_id_nonblocking)\n\n        gobtn = wx.Button(self, label="Go!", pos=(300,355))\n        gobtn.Bind(wx.EVT_BUTTON, lambda event: self.go(listbox_populatedgroupid_locked))\n        global property_dialog\n        property_dialog = self\n        global listbox_groupid\n        listbox_groupid = wx.ListBox(self, pos=(10, 31), size=(375,150))\n\n\n        window.Bind(wx.EVT_TIMER, lambda evt, temp=other_hidden_label: update_continuously(evt, temp))\n\ndef select_other_property(e):\n    global txtctrl_switchkey\n    if (txtctrl_switchkey.GetValue() == ""):\n        wx.MessageBox("You must enter a switch key to select a property.")\n    else:\n        dlg = SelectPropertyDialog()\n        dlg.ShowModal()\n        window.Unbind(wx.EVT_TIMER)\n        dlg.Destroy()\n        return False\n\ndef reset_form(e):\n    global button_test_pragmas\n    button_test_pragmas.SetValue(False)\n    for button in goatc_buttons:\n        button.reset()\n\nclass GoatcButton(wx.Button):\n    toggled = False\n    default_label = ""\n    default_prefix = ""\n\n    def reset(self):\n        self.SetLabel(self.default_label)\n        self.toggled = False\n        self.SetOwnForegroundColour(wx.BLACK)\n\n    def toggle_binary_test_condition(self,e):\n        if (self.toggled):\n            self.reset()\n        else:\n            self.SetLabel(self.default_prefix)\n            self.SetOwnForegroundColour(wx.GREEN)\n            self.toggled = True\n\n    def toggle_integral_test_condition(self,e):\n        if (self.toggled):\n            self.toggled = False\n            self.SetLabel(self.default_label)\n            self.SetOwnForegroundColour(wx.BLACK)\n        else:\n            dialog = wx.TextEntryDialog(self, "Enter integer value",\n                                        "Test Condition", "", wx.OK | wx.CANCEL)\n            if dialog.ShowModal() == wx.ID_OK:\n                try:\n                    number = int(dialog.GetValue())\n                    self.SetOwnForegroundColour(wx.GREEN)\n                    self.toggled = True\n                    self.SetLabel(self.default_prefix+"=" + dialog.GetValue())\n                except:\n                    wx.MessageBox("Invalid value, only integers allowed.", "Error")\n            dialog.Destroy()\n\n    def toggle_int_comma_string_condition(self,e):\n        if (self.toggled):\n            self.toggled = False\n            self.SetLabel(self.default_label)\n            self.SetOwnForegroundColour(wx.BLACK)\n        else:\n            dialog = wx.TextEntryDialog(self, "Enter INT,STRING (an integer, followed by a comma, and then thext)",\n                                        "Test Condition", "", wx.OK | wx.CANCEL)\n            if dialog.ShowModal() == wx.ID_OK:\n                try:\n                    str = dialog.GetValue()\n                    contents = str.split(",")\n                    number = int(contents[0])\n                    text = contents[1]\n                    self.SetOwnForegroundColour(wx.GREEN)\n                    self.toggled = True\n                    self.SetLabel(self.default_prefix+"=" + contents[0] + "," + text)\n                except:\n                    wx.MessageBox("Invalid value, only integers allowed.", "Error")\n            dialog.Destroy()\n\n    def toggle_integral_y_or_n_condition(self,e):\n        if (self.toggled):\n            self.toggled = False\n            self.SetLabel(self.default_label)\n            self.SetOwnForegroundColour(wx.BLACK)\n        else:\n            dialog = wx.TextEntryDialog(self, "Enter Y or N",\n                                        "Test Condition", "", wx.OK | wx.CANCEL)\n            if dialog.ShowModal() == wx.ID_OK:\n                txt = (dialog.GetValue()).upper()\n                if (txt == "Y" or txt == "N"):\n                    self.SetOwnForegroundColour(wx.GREEN)\n                    self.toggled = True\n                    self.SetLabel(self.default_prefix+"=" + txt)\n                else:\n                    wx.MessageBox("Invalid value, only Y or N allowed.", "Error")\n            dialog.Destroy()\n\n    def toggle_string_condition(self,e):\n        if (self.toggled):\n            self.toggled = False\n            self.SetLabel(self.default_label)\n            self.SetOwnForegroundColour(wx.BLACK)\n        else:\n            dialog = wx.TextEntryDialog(self, "Enter text string",\n                                        "Test Condition", "", wx.OK | wx.CANCEL)\n            if dialog.ShowModal() == wx.ID_OK:\n                txt = dialog.GetValue()\n                self.SetOwnForegroundColour(wx.GREEN)\n                self.toggled = True\n                self.SetLabel(self.default_prefix+"=" + txt)\n            dialog.Destroy()\n\n    def __init__(self, panel, label, pos, size, default_bind = True):\n        super().__init__(panel, label=label, pos=pos, size=size)\n        self.default_label = self.GetLabel()\n        self.default_prefix = self.default_label.split("=")[0]\n        self.SetOwnForegroundColour(wx.BLACK)\n        goatc_buttons.append(self)\n        if (default_bind == True):\n            self.Bind(wx.EVT_BUTTON, lambda event: self.toggle_binary_test_condition(event))\n        elif (default_bind == "Integer"):\n            self.Bind(wx.EVT_BUTTON, lambda event: self.toggle_integral_test_condition(event))\n        elif (default_bind == "Integer,String"):\n            self.Bind(wx.EVT_BUTTON, lambda event: self.toggle_int_comma_string_condition(event))\n        elif (default_bind == "YorN"):\n            self.Bind(wx.EVT_BUTTON, lambda event: self.toggle_integral_y_or_n_condition(event))\n        elif (default_bind == "String"):\n            self.Bind(wx.EVT_BUTTON, lambda event: self.toggle_string_condition(event))\n\nsnoring_threads = {}\nwindow = None\n\nhidden_label = None\nlabel_populatedaccountname = None\nlabel_populatedaccountname_locked = False\ntxtctrl_switchkey = None\ntxtctrl_contractid = None\ncombo_contractid = None\nlabel_populatedcontractid = None\ncombo_populatedcontractid_locked = False\ntxtctrl_groupid = None\nlabel_groupid = None\nlabel_populatedgroupid = None\ncombo_populatedgroupid_locked = False\nbutton_test_pragmas = None\n\ndef update_continuously(evt, l):\n    if (l != None):\n        p = l.GetPosition()\n        p.x = p.x + 1\n        p.y = p.y + 1\n        if (p.y > 10):\n            p.x = 0\n            p.y = 0\n        l.SetPosition((p.x,p.y))\n        return None;\n\ndef snore_continuously(l):\n    l.SetLabel("")\n    while l in snoring_threads:\n        try:\n            x = l.GetLabel()\n            x = "." + x\n            if (x == "..........."):\n                x = ""\n            l.SetLabel(x)\n            time.sleep(.5)\n        except:\n            time.sleep(.5)\n\ndef populate_property_id_nonblocking(arg=None):\n    global listbox_groupid\n    global listbox_propertyid\n    listbox_propertyid.Hide()\n    listbox_propertyid.Show()\n    if (listbox_groupid.GetSelection() == wx.NOT_FOUND):\n        wx.MessageBox("You must select a group id first.")\n        return None\n    t = threading.Thread(target=populate_property_id)\n    t.start()\n\ndef populate_property_id():\n    global property_dialog\n    global listbox_propertyid\n    global listbox_populatedpropertyid_locked\n    global label_populatedpropertyid\n\n    str = (listbox_groupid.GetString(listbox_groupid.GetSelection()))\n    strlist = str.split("\\t")\n    if (len(strlist) < 3):\n        wx.MessageBox("ERROR! Invalid selection.")\n        return None\n\n    selectgroup = None\n    contractlist = []\n    count = 0\n    for ctr in strlist:\n        count = count + 1\n        if (count == 1):\n            selectgroup = ctr\n        if (count >= 3):\n            contractlist.append(ctr)\n    pprint.pprint(contractlist)\n\n    if (listbox_populatedpropertyid_locked == True):\n       return False\n\n    listbox_populatedpropertyid_locked = True\n    listbox_propertyid.Disable()\n\n    t = None\n    if (label_populatedpropertyid in snoring_threads):\n       snoring_threads.pop(label_populatedpropertyid)\n       t.join()\n\n    t = threading.Thread(target=snore_continuously, args=[label_populatedpropertyid])\n    snoring_threads[label_populatedpropertyid] = t\n    t.start()\n\n    file_path = os.path.realpath(\'goatc.py\')\n    full_output = "\\n"\n\n    for ctr in contractlist:\n        cmd = file_path + " --cmd ACCOUNT_PROPERTIES --switchKey " + txtctrl_switchkey.GetValue() + " --groupId " + selectgroup + " --contractId " + ctr\n        p = Popen(cmd, stdout=PIPE, stderr=PIPE, shell=True)\n        stdout, stderr = p.communicate()\n        full_output = full_output + stdout.decode("utf-8") + "\\n"\n\n    snoring_threads.pop(label_populatedpropertyid)\n    t.join()\n\n    listbox_propertyid.Hide()\n    listbox_propertyid.Show()\n    count = 0\n    try:\n       if (stderr.decode("utf-8") != ""):\n           label_populatedpropertyid.SetLabel("")\n           listbox_propertyid.Clear()\n           listbox_propertyid.Disable()\n           wx.MessageBox(stderr.decode("utf-8"),"An Error Occurred");\n       else:\n           listbox_propertyid.Clear()\n           groups = full_output.split("\\n")\n           for group in groups:\n               if (group != ""):\n                   count = count + 1\n                   listbox_propertyid.Append((group.replace("|","\\t")))\n                   listbox_propertyid.Enable()\n    finally:\n        listbox_populatedpropertyid_locked = False\n        label_populatedpropertyid.SetLabel("")\n\n    return True\n\ndef populate_group_id_nonblocking(arg=None):\n    global listbox_groupid\n    listbox_groupid.Hide()\n    listbox_groupid.Show()\n    t = threading.Thread(target=populate_group_id)\n    t.start()\n\ndef populate_group_id():\n    global property_dialog\n    global listbox_groupid\n    global listbox_populatedgroupid_locked\n\n    if (listbox_populatedgroupid_locked == True):\n        return False\n\n    listbox_populatedgroupid_locked = True\n    listbox_groupid.Disable()\n\n    t = None\n    if (label_populatedgroupid in snoring_threads):\n        snoring_threads.pop(label_populatedgroupid)\n        t.join()\n\n    t = threading.Thread(target=snore_continuously, args=[label_populatedgroupid])\n    snoring_threads[label_populatedgroupid] = t\n    t.start()\n\n    file_path = os.path.realpath(\'goatc.py\')\n    cmd = file_path + " --cmd ACCOUNT_GROUPS --switchKey " + txtctrl_switchkey.GetValue();\n\n    p = Popen(cmd, stdout=PIPE, stderr=PIPE, shell=True)\n    stdout, stderr = p.communicate()\n\n    snoring_threads.pop(label_populatedgroupid)\n    t.join()\n\n    listbox_groupid.Hide()\n    listbox_groupid.Show()\n    count = 0\n    try:\n        if (stderr.decode("utf-8") != ""):\n            label_populatedgroupid.SetLabel("")\n            listbox_groupid.Clear()\n            listbox_groupid.Disable()\n            wx.MessageBox(stderr.decode("utf-8"),"An Error Occurred");\n        else:\n            listbox_groupid.Clear()\n            groups = stdout.decode("utf-8").split("\\n")\n            for group in groups:\n                if (group != ""):\n                    count = count + 1\n                    listbox_groupid.Append(urllib.parse.unquote(group.replace("|","\\t")))\n                    listbox_groupid.Enable()\n    finally:\n        listbox_populatedgroupid_locked = False\n        label_populatedgroupid.SetLabel("")\n\n    return True\n\ndef populate_contract_id_nonblocking(arg=None):\n    global txtctrl_contractid\n    global combo_contractid\n    txtctrl_contractid.Hide()\n    txtctrl_contractid.Show()\n    combo_contractid.Hide()\n    combo_contractid.Show()\n    t = threading.Thread(target=populate_contract_id)\n    t.start()\n\ndef populate_contract_id():\n    global window\n    global combo_contractid\n    global combo_populatedcontractid_locked\n    if (combo_populatedcontractid_locked == True):\n        return False\n\n    combo_populatedcontractid_locked = True\n    combo_contractid.Disable()\n\n    t = None\n    if (label_populatedcontractid in snoring_threads):\n        snoring_threads.pop(label_populatedcontractid)\n        t.join()\n\n    t = threading.Thread(target=snore_continuously, args=[label_populatedcontractid])\n    snoring_threads[label_populatedcontractid] = t\n    t.start()\n\n    file_path = os.path.realpath(\'goatc.py\')\n    cmd = file_path + " --cmd ACCOUNT_CONTRACTS --switchKey " + txtctrl_switchkey.GetValue();\n\n    p = Popen(cmd, stdout=PIPE, stderr=PIPE, shell=True)\n    stdout, stderr = p.communicate()\n\n    snoring_threads.pop(label_populatedcontractid)\n    t.join()\n\n    combo_contractid.Hide()\n    combo_contractid.Show()\n\n    try:\n        if (stderr.decode("utf-8") != ""):\n            label_populatedcontractid.SetLabel("")\n            combo_contractid.Clear()\n            combo_contractid.Disable()\n            wx.MessageBox(stderr.decode("utf-8"),"An Error Occurred");\n        else:\n            combo_contractid.Clear()\n            combo_contractid.Disable()\n            contracts = stdout.decode("utf-8").split("\\n")\n            for contract in contracts:\n                if (contract != ""):\n                    combo_contractid.Append(contract)\n                    combo_contractid.Enable()\n            try:\n                combo_contractid.SetSelection(0)\n            finally:\n                label_populatedcontractid.SetLabel("")\n    finally:\n        combo_populatedcontractid_locked = False\n    return True\n\n\ndef populate_account_name_nonblocking(arg=None):\n    global txtctrl_switchkey\n    txtctrl_switchkey.Hide()\n    txtctrl_switchkey.Show()\n    t = threading.Thread(target=populate_account_name)\n    t.start()\n\ndef populate_account_name():\n    global window\n    global label_populatedaccountname\n    global label_populatedaccountname_locked\n    if (label_populatedaccountname_locked == True):\n        return False\n\n    label_populatedaccountname_locked = True\n    t = None\n    if (label_populatedaccountname in snoring_threads):\n        snoring_threads.pop(label_populatedaccountname)\n        t.join()\n\n    t = threading.Thread(target=snore_continuously, args=[label_populatedaccountname])\n    snoring_threads[label_populatedaccountname] = t\n    t.start()\n\n    file_path = os.path.realpath(\'goatc.py\')\n    cmd = file_path + " --cmd ACCOUNT_NAME --switchKey " + txtctrl_switchkey.GetValue();\n\n    p = Popen(cmd, stdout=PIPE, stderr=PIPE, shell=True)\n    stdout, stderr = p.communicate()\n\n    snoring_threads.pop(label_populatedaccountname)\n    t.join()\n\n    if (stderr.decode("utf-8") != ""):\n        label_populatedaccountname.SetLabel("")\n        wx.MessageBox(stderr.decode("utf-8"),"An Error Occurred");\n    else:\n        label_populatedaccountname.SetLabel(stdout.decode("utf-8"))\n    label_populatedaccountname_locked = False\n    return True\n\ndef showme():\n    contractId = get_input_args().args.contractid\n    if (contractId == None):\n        contractId = ""\n    groupId = get_input_args().args.groupid\n    if (groupId == None):\n        groupId = ""\n    propertyId = get_input_args().args.propertyid\n    if (propertyId == None):\n        propertyId = ""\n    versionId = get_input_args().args.versionid\n    if (versionId == None):\n        versionId = ""\n\n    app = wx.App()\n\n    global window\n    window = wx.Frame(None, title="GOATC UI", size=(650, 475), pos=(50,50))\n    panel = wx.Panel(window)\n\n    global hidden_label\n    hidden_label = wx.StaticText(panel, label="", pos=(0, 0))\n    hidden_label.Hide()\n\n    window.timer = wx.Timer(window)\n    window.timer.Start(100)\n    #window.Bind(wx.EVT_TIMER, lambda evt, temp = hidden_label: update_continuously(evt, temp))\n\n    #button_accountname = wx.Button(panel, label="Account Name               ", pos=(125, 10), size=(105,20), style=wx.BU_LEFT)\n    #button_accountname.Bind(wx.EVT_BUTTON, populate_account_name_nonblocking)\n    global txtctrl_switchkey\n    current_key = get_api_client().current_switchkey\n    if current_key == None:\n        current_key = ""\n    txtctrl_switchkey = wx.TextCtrl(panel, value=current_key, pos=(10, 30))\n    label_switchkey = wx.StaticText(panel, label="Switch Key", pos=(10, 10))\n    #global label_populatedaccountname\n    #label_populatedaccountname = wx.StaticText(panel, label="* click [Account Name]", pos=(125, 30))\n\n    label_contractid = wx.StaticText(panel, label="Contract Id", pos=(10, 60))\n    #button_contractid = wx.Button(panel, label="Contract Id List              ", pos=(125, 60), size=(130,20), style=wx.BU_LEFT)\n    #button_contractid.Bind(wx.EVT_BUTTON, populate_contract_id_nonblocking)\n    global txtctrl_contractid\n    txtctrl_contractid = wx.TextCtrl(panel, value=contractId, pos=(10, 80))\n    #global combo_contractid\n    #combo_contractid = wx.ComboBox(panel, 1, style=wx.CB_DROPDOWN | wx.CB_READONLY, size=(125,25), pos=(125,79))\n    #combo_contractid.Append("* click [Contract Id List]")\n    #combo_contractid.SetSelection(0)\n    #combo_contractid.Disable()\n    #global label_populatedcontractid\n    #label_populatedcontractid = wx.StaticText(panel, label="", pos=(125, 92))\n\n    global label_groupid\n    label_groupid = wx.StaticText(panel, label="Group Id", pos=(10, 110))\n    global txtctrl_groupid\n    txtctrl_groupid = wx.TextCtrl(panel, value=groupId, pos=(10, 130))\n    #button_groupid = wx.Button(panel, label="Group Id List              ", pos=(125, 110), size=(130,20), style=wx.BU_LEFT)\n    #button_groupid.Bind(wx.EVT_BUTTON, populate_group_id_nonblocking)\n    #global combo_groupid\n    #combo_groupid = wx.ComboBox(panel, 1, style=wx.CB_DROPDOWN | wx.CB_READONLY, size=(125,25), pos=(125,129))\n    #combo_groupid.Append("* click [Group Id List]")\n    #combo_groupid.SetSelection(0)\n    #combo_groupid.Disable()\n    #global label_populatedgroupid\n    #label_populatedgroupid = wx.StaticText(panel, label="", pos=(125, 142))\n\n    label_propertyid = wx.StaticText(panel, label="Property Id", pos=(10, 160))\n    txtctrl_propertyid = wx.TextCtrl(panel, value=propertyId, pos=(10, 180))\n\n    label_propertyid = wx.StaticText(panel, label="Version Id", pos=(10, 210))\n    txtctrl_propertyid = wx.TextCtrl(panel, value=versionId, pos=(10, 230))\n\n    button_propertyselector = wx.Button(panel, label="Select Other\\nProperty", pos=(10, 260), size=(105,40))\n    button_propertyselector.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n    button_propertyselector.Bind(wx.EVT_BUTTON, select_other_property)\n\n    button_propertyselector = wx.Button(panel, label="Use This\\nProperty", pos=(10, 300), size=(105,40))\n    button_propertyselector.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_accountinfo = wx.Button(panel, label="Show Helpful\\nInformation", pos=(10, 340), size=(105,40))\n    button_accountinfo.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    label_cfgfile = wx.StaticText(panel, label="Configuration file:", pos=(130, 10))\n    label_cfgfilevalue = wx.StaticText(panel, label="[click Use This Property]", pos=(240, 10))\n\n    label_vars = wx.StaticText(panel, label="Vars:", pos=(130, 264+10))\n    list_vars = wx.ListBox(panel, 1, style=wx.LB_MULTIPLE, size=(225,60), pos=(130,280+10))\n    button_equalsvar = wx.Button(panel, label="Equals", pos=(165, 21+10), size=(48,500))\n    button_equalsvar = wx.Button(panel, label="Equals", pos=(165, 21+10), size=(48,500))\n    button_equalsvar.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n    button_novar = wx.Button(panel, label="NoVAR", pos=(213, 21+10), size=(48,500))\n    button_novar.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n    button_noval = wx.Button(panel, label="NoVAL", pos=(261, 21+10), size=(48,500))\n    button_noval.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n    button_delvar = wx.Button(panel, label="D", pos=(308, 21+10), size=(25,500))\n    button_delvar.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n    button_clrvar = wx.Button(panel, label="C", pos=(332, 21+10), size=(23,500))\n    button_clrvar.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n\n    label_rsphdrs = wx.StaticText(panel, label="Rsp hdrs:", pos=(360, 264+10))\n    list_rsphdrs = wx.ListBox(panel, 1, style=wx.LB_MULTIPLE, size=(230,60), pos=(360,280+10))\n    button_addrsphdr = wx.Button(panel, label="Add", pos=(420, 21+10), size=(40,500))\n    button_addrsphdr.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n    button_missrsphdr = wx.Button(panel, label="Miss", pos=(460, 21+10), size=(40,500))\n    button_missrsphdr.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n    button_delrsphdr = wx.Button(panel, label="Del", pos=(500, 21+10), size=(40,500))\n    button_delrsphdr.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n    button_clearrsphdr = wx.Button(panel, label="Clear", pos=(540, 21+10), size=(50,500))\n    button_clearrsphdr.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    label_hostnames = wx.StaticText(panel, label="Hostnames:", pos=(130, 32))\n    label_populatedhostnames = wx.StaticText(panel, label="...", pos=(130, 37))\n    list_hostnames = wx.ListBox(panel, 1, style=wx.LB_MULTIPLE, size=(225,75), pos=(130,53))\n    button_hostnames = wx.Button(panel, label="Unselect All", pos=(210, 21), size=(145,40))\n    button_hostnames.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    label_hostnames = wx.StaticText(panel, label="Req hdrs:", pos=(360, 32))\n    #label_populatedheaders = wx.StaticText(panel, label="...", pos=(360, 37))\n    list_headers = wx.ListBox(panel, 1, style=wx.LB_MULTIPLE, size=(230,75), pos=(360,53))\n    button_addheader = wx.Button(panel, label="Add", pos=(420, 21), size=(40,40))\n    button_addheader.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n    button_modheader = wx.Button(panel, label="Mod", pos=(460, 21), size=(40,40))\n    button_modheader.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n    button_delheader = wx.Button(panel, label="Del", pos=(500, 21), size=(40,40))\n    button_delheader.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n    button_clearheader = wx.Button(panel, label="Clear", pos=(540, 21), size=(50,40))\n    button_clearheader.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_test_status = GoatcButton(panel, label="STATUS=___", pos=(130, 120), size=(80, 40), default_bind="Integer")\n    button_test_status.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_test_cpcode = GoatcButton(panel, label="CPCODE=__________", pos=(210, 120), size=(120, 40), default_bind="Integer")\n    button_test_cpcode.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_test_sureroute = GoatcButton(panel, label="SUREROUTE", pos=(330, 120), size=(80, 40))\n    button_test_sureroute.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_test_sureroute = GoatcButton(panel, label="PREFETCH", pos=(410, 120), size=(80, 40))\n    button_test_sureroute.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_test_gzip = GoatcButton(panel, label="GZIP", pos=(490, 120), size=(40, 40))\n    button_test_gzip.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_test_nostore = GoatcButton(panel, label="NOSTOR", pos=(530, 120), size=(60, 40))\n    button_test_nostore.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_test_redirect = GoatcButton(panel, label="REDIRECT=___,_________________________________________________________", pos=(130, 142), size=(360, 40),default_bind="Integer,String")\n    button_test_redirect.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_test_cache = GoatcButton(panel, label="CACHE=__,______", pos=(490, 142), size=(100, 40),default_bind="Integer,String")\n    button_test_cache.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_test_bypass = GoatcButton(panel, label="BYPASS", pos=(130, 164), size=(60, 40))\n    button_test_bypass.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_test_exclude = GoatcButton(panel, label="EXCLUDEPARAMS", pos=(190, 164), size=(100, 40))\n    button_test_exclude.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_test_logrefer = GoatcButton(panel, label="LOGREFER=_", pos=(290, 164), size=(80, 40),default_bind="YorN")\n    button_test_logrefer.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_test_loghost = GoatcButton(panel, label="LOGHOST=_", pos=(370, 164), size=(75, 40),default_bind="YorN")\n    button_test_loghost.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_test_loglang = GoatcButton(panel, label="LOGLANG=_", pos=(445, 164), size=(75, 40),default_bind="YorN")\n    button_test_loglang.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_test_keycontains = GoatcButton(panel, label="KEYCONTAINS=_________________________________________________________", pos=(130, 186), size=(360, 40),default_bind="String")\n    button_test_keycontains.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_test_logcook = GoatcButton(panel, label="LOGCUSTOM=_", pos=(490, 164), size=(100, 83),default_bind="YorN")\n    button_test_logcook.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_test_logcook = GoatcButton(panel, label="LOGCOOKIES=_", pos=(490, 208), size=(100, 40),default_bind="YorN")\n    button_test_logcook.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_test_keyomits = GoatcButton(panel, label="KEYOMITS=_________________________________________________________", pos=(130, 208), size=(360, 40),default_bind="String")\n    button_test_keyomits.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_test_hardcode = GoatcButton(panel, label="HARDCODE=_________________________________________________________", pos=(130, 230), size=(360, 40),default_bind="String")\n    button_test_hardcode.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_test_secpolicy = GoatcButton(panel, label="SECPOL=________", pos=(490, 208), size=(100, 40),default_bind="String")\n    button_test_secpolicy.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    button_test_notd = GoatcButton(panel, label="NOTD", pos=(490, 230), size=(100, 40))\n    button_test_notd.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    voffset = 25\n    label_paths = wx.StaticText(panel, label="Request path (not including hostname):", pos=(130, 355))\n    txtctrl_path = wx.TextCtrl(panel, value="/", pos=(375, 353), size=(215,22))\n\n    button_addtest = wx.Button(panel, label="Update Test Script List", pos=(130, 380+voffset), size=(170, 40))\n    button_addtest.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n    button_cleartest = wx.Button(panel, label="Reset Form", pos=(300, 380+voffset), size=(100, 40))\n    button_cleartest.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n    button_cleartest.Bind(wx.EVT_BUTTON, reset_form)\n\n    button_savetest = wx.Button(panel, label="Save", pos=(400, 380+voffset), size=(40, 40))\n    button_savetest.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n    button_copytest = wx.Button(panel, label="Copy", pos=(440, 380+voffset), size=(40, 40))\n    button_copytest.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n    button_runtest = wx.Button(panel, label="Load", pos=(480, 380+voffset), size=(40, 40))\n    button_runtest.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n    button_goatc = wx.Button(panel, label="GO ATC!", pos=(520, 380+voffset), size=(70, 40))\n    button_goatc.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    combo_templates = wx.ComboBox(panel, 1, style=wx.CB_DROPDOWN | wx.CB_READONLY, size=(325,25), pos=(130,358+voffset))\n    button_templates = wx.Button(panel, label="Apply Template Instead", pos=(460, 350+voffset), size=(130, 40))\n    button_templates.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    global button_test_pragmas\n    button_test_pragmas = wx.CheckBox(panel, label="PRAGMAS", pos=(522, 164), size=(95, 40))\n    button_test_pragmas.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))\n\n    window.Show(True)\n\n    app.MainLoop()\n\n    while len(snoring_threads) > 0:\n        try:\n            for t in snoring_threads:\n                th = snoring_threads.pop(t)\n                th.join()\n        except:\n            print_err("Cleaning up threads...\\n")\n    util.die(0, "UI window closed.  Exiting gracefully.")\n')
    __stickytape_write_module('commands.py', b'import util, pprint, re, json, uuid, time, wx, os, gui, requests, urllib\nfrom util import get_api_client, get_input_args, print_err, pprint_err\n\ndef reject_blank_switchkey():\n    if (get_api_client().current_switchkey == None or get_api_client().current_switchkey == ""):\n        util.die(-1,"--switchKey argument must not be blank for this command.")\n\ndef docmd_ACCOUNT_NAME():\n    reject_blank_switchkey()\n    parameters = {\'accountSwitchKey\': get_api_client().current_switchkey}\n\n    json_data = get_api_client().httpCaller.getJSONResult(\'/papi/v1/groups\', parameters)\n    if ("accountName" in json_data and get_api_client().get_last_response_code() == 200):\n        print (json_data["accountName"])\n        return json_data\n\n    print_err("Could not retrieve account name.\\nStatus code: ")\n    print_err(get_api_client().get_last_response_code())\n    print_err("\\nJSON response body:")\n    print_err(get_api_client().get_last_endpoint_result().json());\n    return json_data\n\ndef docmd_ACCOUNT_CONTRACTS():\n    reject_blank_switchkey()\n    parameters = {\'accountSwitchKey\': get_api_client().current_switchkey}\n    json_data = get_api_client().httpCaller.getJSONResult(\'/papi/v1/contracts\', parameters)\n    if ("contracts" in json_data and get_api_client().get_last_response_code() == 200):\n        try:\n            items = json_data["contracts"]["items"]\n            for item in items:\n                print(item["contractId"].split("ctr_")[1] + " - " + item["contractTypeName"])\n            return json_data\n        except:\n            print_err("Error while processing contract API response.\\n")\n\n    print_err("Could not retrieve account contracts.\\nStatus code: ")\n    print_err(get_api_client().get_last_response_code())\n    print_err("\\nJSON response body:")\n    print_err(get_api_client().get_last_endpoint_result().json());\n    return json_data\n\ndef docmd_ACCOUNT_GROUPS():\n    reject_blank_switchkey()\n    parameters = {\'accountSwitchKey\': get_api_client().current_switchkey}\n    json_data = get_api_client().httpCaller.getJSONResult(\'/papi/v1/groups\', parameters)\n    if ("groups" in json_data and get_api_client().get_last_response_code() == 200):\n        try:\n            items = json_data["groups"]["items"]\n\n            for item in items:\n                contracts = item["contractIds"]\n                contract_str = ""\n                for c in contracts:\n                    contract_str = "|" + urllib.parse.quote(c.split("ctr_")[1],safe=\' \')\n                print(urllib.parse.quote(item["groupId"].split("grp_")[1], safe=\' \') + "|" + urllib.parse.quote(item["groupName"],safe=\' \') + contract_str)\n            return json_data\n        except:\n            print_err("Error while processing group API response.\\n")\n\n    print_err("Could not retrieve account groups.\\nStatus code: ")\n    print_err(get_api_client().get_last_response_code())\n    print_err("\\nJSON response body:")\n    print_err(get_api_client().get_last_endpoint_result().json());\n    return json_data\n\ndef addargs_ACCOUNT_PROPERTIES():\n    get_input_args().parser.add_argument("--groupId", required=False, help="groupId", action="store", dest="groupid")\n    get_input_args().parser.add_argument("--contractId", required=False, help="contractId", action="store", dest="contractid")\n\ndef docmd_ACCOUNT_PROPERTIES():\n    reject_blank_switchkey()\n    contractId = get_input_args().args.contractid\n    groupId = get_input_args().args.groupid\n    if (contractId == None or groupId == None):\n        print_err("This command required two additional arguments: --contractId and --groupId")\n        return None\n\n    parameters = {\'accountSwitchKey\': get_api_client().current_switchkey,\n                  \'contractId\': contractId,\n                  \'groupId\': groupId\n                  }\n    json_data = get_api_client().httpCaller.getJSONResult(\'/papi/v1/properties\', parameters)\n    if (get_api_client().get_last_response_code() == 200):\n        pprint.pprint(json_data);\n        return json_data;\n\n    print_err("Could not retrieve account groups.\\nStatus code: ")\n    print_err(get_api_client().get_last_response_code())\n    print_err("\\nJSON response body:")\n    print_err(get_api_client().get_last_endpoint_result().json());\n    return json_data\n\ndef addargs_PROPERTY_HOSTNAMES():\n    get_input_args().parser.add_argument("--groupId", required=False, help="groupId", action="store", dest="groupid")\n    get_input_args().parser.add_argument("--contractId", required=False, help="contractId", action="store", dest="contractid")\n    get_input_args().parser.add_argument("--propertyId", required=False, help="propertyId", action="store", dest="propertyid")\n    get_input_args().parser.add_argument("--versionId", required=False, help="versionId", action="store", dest="versionid")\n\ndef docmd_PROPERTY_HOSTNAMES():\n    reject_blank_switchkey()\n    contractId = get_input_args().args.contractid\n    groupId = get_input_args().args.groupid\n    propertyId = get_input_args().args.propertyid\n    versionId = get_input_args().args.versionid\n\n    if (contractId == None or groupId == None or propertyId == None or versionId == None):\n        print_err("This command required four additional arguments: --contractId, --groupId, --propertyId and --versionId")\n        return None\n\n    parameters = {\'accountSwitchKey\': get_api_client().current_switchkey,\n                  \'contractId\': contractId,\n                  \'groupId\': groupId\n                  }\n\n    json_data = get_api_client().httpCaller.getJSONResult(\'/papi/v1/properties/%s/versions/%s/hostnames\' % (propertyId, versionId), parameters)\n    if ("hostnames" in json_data and get_api_client().get_last_response_code() == 200):\n        items = json_data["hostnames"]["items"]\n        for item in items:\n            print(item["cnameFrom"])\n        return json_data;\n\n    print_err("Could not retrieve property hostnames.\\nStatus code: ")\n    print_err(get_api_client().get_last_response_code())\n    print_err("\\nJSON response body:")\n    print_err(get_api_client().get_last_endpoint_result().json());\n    return json_data\n\n\ndef addargs_PROPERTY_XML():\n    get_input_args().parser.add_argument("--groupId", required=False, help="groupId", action="store", dest="groupid")\n    get_input_args().parser.add_argument("--contractId", required=False, help="contractId", action="store", dest="contractid")\n    get_input_args().parser.add_argument("--propertyId", required=False, help="propertyId", action="store", dest="propertyid")\n    get_input_args().parser.add_argument("--versionId", required=False, help="versionId", action="store", dest="versionid")\n\ndef docmd_PROPERTY_XML():\n    reject_blank_switchkey()\n    contractId = get_input_args().args.contractid\n    groupId = get_input_args().args.groupid\n    propertyId = get_input_args().args.propertyid\n    versionId = get_input_args().args.versionid\n\n    if (contractId == None or groupId == None or propertyId == None or versionId == None):\n        print_err("This command required four additional arguments: --contractId, --groupId, --propertyId and --versionId")\n        return None\n\n    parameters = {\'accountSwitchKey\': get_api_client().current_switchkey,\n                  \'contractId\': contractId,\n                  \'groupId\': groupId\n                  }\n    xml_data = get_api_client().httpCaller.getXMLResult(\'/papi/v1/properties/%s/versions/%s\' % (propertyId, versionId), parameters)\n    if (get_api_client().get_last_response_code() == 200):\n        pprint.pprint(xml_data);\n        return xml_data;\n\n    print_err("Could not retrieve property XML.\\nStatus code: ")\n    print_err(get_api_client().get_last_response_code())\n    print_err("\\nJSON response body:")\n    print_err(get_api_client().get_last_endpoint_result().json());\n    return xml_data\n\ndef addargs_PROPERTY_JSON():\n    get_input_args().parser.add_argument("--groupId", required=False, help="groupId", action="store", dest="groupid")\n    get_input_args().parser.add_argument("--contractId", required=False, help="contractId", action="store", dest="contractid")\n    get_input_args().parser.add_argument("--propertyId", required=False, help="propertyId", action="store", dest="propertyid")\n    get_input_args().parser.add_argument("--versionId", required=False, help="versionId", action="store", dest="versionid")\n\ndef docmd_PROPERTY_JSON():\n    reject_blank_switchkey()\n    contractId = get_input_args().args.contractid\n    groupId = get_input_args().args.groupid\n    propertyId = get_input_args().args.propertyid\n    versionId = get_input_args().args.versionid\n\n    if (contractId == None or groupId == None or propertyId == None or versionId == None):\n        print_err("This command required four additional arguments: --contractId, --groupId, --propertyId and --versionId")\n        return None\n\n    parameters = {\'accountSwitchKey\': get_api_client().current_switchkey,\n                  \'contractId\': contractId,\n                  \'groupId\': groupId\n                  }\n    json_data = get_api_client().httpCaller.getJSONResult(\'/papi/v1/properties/%s/versions/%s\' % (propertyId, versionId), parameters)\n    if (get_api_client().get_last_response_code() == 200):\n        pprint.pprint(json_data);\n        return json_data;\n\n    print_err("Could not retrieve property JSON.\\nStatus code: ")\n    print_err(get_api_client().get_last_response_code())\n    print_err("\\nJSON response body:")\n    print_err(get_api_client().get_last_endpoint_result().json());\n    return json_data\n\ndef addargs_PROPERTY_RULES_JSON():\n    get_input_args().parser.add_argument("--groupId", required=False, help="groupId", action="store", dest="groupid")\n    get_input_args().parser.add_argument("--contractId", required=False, help="contractId", action="store", dest="contractid")\n    get_input_args().parser.add_argument("--propertyId", required=False, help="propertyId", action="store", dest="propertyid")\n    get_input_args().parser.add_argument("--versionId", required=False, help="versionId", action="store", dest="versionid")\n\ndef docmd_PROPERTY_RULES_JSON():\n    reject_blank_switchkey()\n    contractId = get_input_args().args.contractid\n    groupId = get_input_args().args.groupid\n    propertyId = get_input_args().args.propertyid\n    versionId = get_input_args().args.versionid\n\n    if (contractId == None or groupId == None or propertyId == None or versionId == None):\n        print_err("This command required four additional arguments: --contractId, --groupId, --propertyId and --versionId")\n        return None\n\n    parameters = {\'accountSwitchKey\': get_api_client().current_switchkey,\n                  \'contractId\': contractId,\n                  \'groupId\': groupId,\n                  \'validateRules\': \'false\',\n                  \'validateMode\': \'fast\'\n                  }\n    json_data = get_api_client().httpCaller.getJSONResult(\'/papi/v1/properties/%s/versions/%s/rules\' % (propertyId, versionId), parameters)\n    if (get_api_client().get_last_response_code() == 200):\n        pprint.pprint(json_data);\n        return json_data;\n\n    print_err("Could not retrieve property JSON.\\nStatus code: ")\n    print_err(get_api_client().get_last_response_code())\n    print_err("\\nJSON response body:")\n    print_err(get_api_client().get_last_endpoint_result().json());\n    return json_data\n\ndef docmd_GET_TEST_CATALOG_TEMPLATE():\n    reject_blank_switchkey()\n    parameters = {\'accountSwitchKey\': get_api_client().current_switchkey}\n\n    json_data = get_api_client().httpCaller.getJSONResult(\'/test-management/v2/functional/test-catalog/template\', parameters)\n    if (get_api_client().get_last_response_code() == 200):\n        pprint.pprint(json_data)\n        return json_data\n\n    print_err("Could not retrieve account name.\\nStatus code: ")\n    print_err(get_api_client().get_last_response_code())\n    print_err("\\nJSON response body:")\n    print_err(get_api_client().get_last_endpoint_result().json());\n    return json_data\n\ndef create_test_condition(client_profiles, caseids, requestid, jsonstr):\n    reject_blank_switchkey()\n    try:\n        parameters = {\'accountSwitchKey\': get_api_client().current_switchkey\n                      }\n\n        time.sleep(.5)\n        json_data = get_api_client().httpCaller.postAcceptingJSON(\n            \'/test-management/v2/functional/test-catalog/conditions\', parameters, json.loads(jsonstr))\n        conditionid = None\n        try:\n            conditionid = str(json_data["errors"][0]["existingEntities"][0]["conditionId"])\n            print_err("Condition id success!\\n")\n        except:\n            try:\n                print_err(str(json_data["conditionId"]))\n                conditionid = str(json_data["conditionId"])\n                print_err("Condition id success!\\n")\n            except:\n                print_err("Failed to verify successfully created condition id\\n", color=\'red\')\n                pprint_err(json_data,color="yellow")\n                print_err("\\n")\n        if (conditionid != None):\n            print_err("Condition id is " + conditionid + "\\n")\n            print_err("Generating test cases...\\n")\n\n            testcases = []\n            for profile in client_profiles:\n                profileId = profile["clientProfileId"]\n                thiscase = {}\n                thiscase["testRequestId"] = requestid\n                thiscase["conditionId"] = conditionid\n                thiscase["clientProfileId"] = profileId\n                testcases.append(thiscase)\n            parameters = {\'accountSwitchKey\': get_api_client().current_switchkey}\n            time.sleep(.5)\n            json_data = get_api_client().httpCaller.postAcceptingJSON(\'/test-management/v2/functional/test-cases\',\n                                                                      parameters, testcases)\n            caseid1 = None\n            success1 = None\n            failure1 = None\n            try:\n                caseid1 = str(json_data["failures"][0]["existingEntities"][0]["testCaseId"])\n                print_err("Case id 1 success! " + caseid1 + "\\n")\n                failure1 = 1\n            except:\n                try:\n                    caseid1 = str(json_data["successes"][0]["testCaseId"])\n                    print_err("Case id 1 success! " + caseid1 + "\\n")\n                    success1 = 1\n                except:\n                    print_err("Failed to verify successfully created case id 1\\n", color=\'red\')\n                    pprint_err(json_data,color=\'yellow\')\n            caseid2 = None\n            try:\n                caseid2 = str(json_data["failures"][0]["existingEntities"][1]["testCaseId"])\n                print_err("Case id 2 success! " + caseid2 + "\\n")\n            except:\n                try:\n                    caseid2 = str(json_data["successes"][1]["testCaseId"])\n                    print_err("Case id 2 success! " + caseid2 + "\\n")\n                except:\n                    if (failure1 == None):\n                        try:\n                            caseid2 = str(json_data["failures"][0]["existingEntities"][0]["testCaseId"])\n                        except:\n                            print_err("Failed to verify successfully created case id 2\\n", color=\'red\')\n                            pprint_err(json_data, color=\'yellow\')\n                    elif (success1 == None):\n                        try:\n                            caseid2 = str(json_data["successes"][0]["testCaseId"])\n                        except:\n                            print_err("Failed to verify successfully created case id 2\\n", color=\'red\')\n                            pprint_err(json_data, color=\'yellow\')\n                    if (caseid2 != None):\n                        print_err("Case id 2 success! " + caseid2 + "\\n")\n            if (caseid1 != None):\n                caseids.append(caseid1)\n            if (caseid2 != None):\n                caseids.append(caseid2)\n    except:\n        print_err("ERROR! Exception occurred while creating test condition! Some tests may not have been created.\\n", color="red")\n\n    return caseids\n\ndef addargs_EXECUTE_PROPERTY_ATC_SCRIPTS():\n    get_input_args().parser.add_argument("--groupId", required=False, help="groupId", action="store", dest="groupid")\n    get_input_args().parser.add_argument("--contractId", required=False, help="contractId", action="store", dest="contractid")\n    get_input_args().parser.add_argument("--propertyId", required=False, help="propertyId", action="store", dest="propertyid")\n    get_input_args().parser.add_argument("--versionId", required=False, help="versionId", action="store", dest="versionid")\n    get_input_args().parser.add_argument("--testSuiteName", required=False, help="testSuiteName", action="store", dest="testsuitename")\n    get_input_args().parser.add_argument("--localFile", required=False, help="localFile", action="store", dest="localfile")\n    get_input_args().parser.add_argument("--ui", required=False, help="ui", action="store_true", dest="ui")\n\ndef docmd_EXECUTE_PROPERTY_ATC_SCRIPTS():\n    reject_blank_switchkey()\n    contractId = get_input_args().args.contractid\n    groupId = get_input_args().args.groupid\n    propertyId = get_input_args().args.propertyid\n    versionId = get_input_args().args.versionid\n    testSuiteName = get_input_args().args.testsuitename\n    ui = get_input_args().args.ui\n    localFile = get_input_args().args.localfile\n\n    testscripts = []\n\n    if (ui):\n        gui.showme()\n\n    if (ui == False and (contractId == None or groupId == None or propertyId == None or versionId == None or testSuiteName == None)):\n        print_err("This command required four additional arguments: --contractId, --groupId, --propertyId, --versionId and --testSuiteName")\n        return None\n\n    parameters = {\'accountSwitchKey\': get_api_client().current_switchkey}\n    profiles_data = get_api_client().httpCaller.getJSONResult(\n        \'/test-management/v2/functional/client-profiles\', parameters)\n\n    parameters = {\'accountSwitchKey\': get_api_client().current_switchkey,\n                  \'contractId\': contractId,\n                  \'groupId\': groupId,\n                  \'validateRules\': \'false\',\n                  \'validateMode\': \'fast\'\n                  }\n    print_err("Downloading configuration JSON...\\n")\n    json_data = get_api_client().httpCaller.getJSONResult(\'/papi/v1/properties/%s/versions/%s/rules\' % (propertyId, versionId), parameters)\n    if (get_api_client().get_last_response_code() == 200):\n        if localFile == None:\n            tmp = re.findall("\\"comments\\" : \\".*ATC!.*\\"", get_api_client().get_last_endpoint_result().text)\n\n            for txt in tmp:\n                mgroup = re.findall(\'ATC!(.*?@.*?)@\', txt)\n                for m in mgroup:\n                    found = m\n                    details = found.split(\'@\')\n                    if (details[0] == "URL"):\n                        try:\n                            link = details[1]\n                            f = requests.get(link)\n                            lines = str(f.text).split("@\\n")\n                            for line in lines:\n                                if (line != ""):\n                                    testscripts.append(line)\n                        except:\n                            print_err("Exception occurred while downloading test scripts from URL: " + link + ", these test scripts were not added.",color="yellow")\n                    else:\n                        testscripts.append(found)\n        else:\n            try:\n                print_err("Local file supplied, reading test scripts from " + localFile + "\\n")\n                text_file = open(localFile, "r")\n                data = text_file.read()\n                text_file.close()\n                lines = data.split("@\\n")\n                for line in lines:\n                    if (line != ""):\n                        testscripts.append(line)\n            except:\n                print_err("ERROR! Exception ocurred while reading test scripts from local file.\\n", color="red")\n\n        if (len(testscripts) > 0):\n            # generate suite and associate\n            testsuite = {}\n            testsuite["testSuiteName"] = f"{testSuiteName} {uuid.uuid4()}"\n            testsuite[\n                "testSuiteDescription"] = f"This test suite was automatically generated by the goatc script."\n            testsuite["locked"] = False\n            testsuite["stateful"] = False\n            parameters = {\'accountSwitchKey\': get_api_client().current_switchkey\n                          }\n\n            generated = None\n            try:\n                generated = get_api_client().httpCaller.postAcceptingJSON(\'/test-management/v2/functional/test-suites\',\n                                                                      parameters, testsuite)\n                newid = generated["testSuiteId"]\n            except:\n                print_err("\\n")\n                pprint_err(generated,color="yellow")\n                print_err("\\n")\n                util.die(-1,"Exception while creating test suite.  Aborting.")\n\n            for script in testscripts:\n                instructions = script.split(\'#\')\n                if (len(instructions) < 2):\n                    print_err("Skipping " + script + ", each script must have 1 request and at least 1 parameter.",color=\'red\')\n                else:\n                    request = instructions[0].split(\'@\')\n                    if (len(request) != 2):\n                        print_err("Skipping " + script + ", request syntax must be GET@URL#parameterlist",color=\'red\')\n                    else:\n                        if (request[0] != "GET"):\n                            print_err("Skipping " + script + ", only GET requests are supported at this time.",color=\'red\')\n                        else:\n                            url = request[1]\n                            added_request_headers = {}\n                            modified_request_headers = {}\n                            status = None\n                            cpcode = None\n                            sureroute = None\n                            prefetch = None\n                            redirect_status = None\n                            redirect_location = None\n                            gzip = None\n                            nogzip = None\n                            cache_duration = None\n                            cache_interval = None\n                            nostore = None\n                            bypass = None\n                            varis = {}\n                            excludequery = None\n                            headeris = {}\n                            keycontains = []\n                            keyomits = []\n                            novarval = []\n                            novar = []\n                            noheader = []\n                            dolog = []\n                            nolog = []\n                            secpolicy = None;\n                            notd = None\n\n                            print_err("URL is: " + url +"\\n")\n                            for i in range(1,len(instructions)):\n                                if (instructions[i] == \'pragmas\'):\n                                    print_err("Adding pragma headers...\\n")\n                                    added_request_headers["Pragma"] = "akamai-x-cache-on, akamai-x-cache-remote-on, akamai-x-get-cache-key, akamai-x-get-request-id, akamai-x-get-true-cache-key, akamai-x-get-extracted-values"\n                                elif (instructions[i] != \'\' and instructions[i][0] == \'^\'):\n                                    print_err("Adding arbitrary header  " + instructions[i] + "\\n")\n                                    pair = instructions[i].split("=");\n                                    if (len(pair) != 2):\n                                        print_err("Skipping " + instructions[i] + ", syntax must be key=value",color=\'red\')\n                                    else:\n                                        decoded = pair[1]\n                                        decoded = decoded.replace("%3D","=")\n                                        print_err("Continuing with " + pair[0][1:] + " = " + decoded + "\\n")\n                                        added_request_headers[pair[0][1:]] = decoded\n                                elif (instructions[i] != \'\' and instructions[i][0] == \'~\'):\n                                    print_err("Modifying arbitrary header  " + instructions[i] + "\\n")\n                                    pair = instructions[i].split("=");\n                                    if (len(pair) != 2):\n                                        print_err("Skipping " + instructions[i] + ", syntax must be key=value",color=\'red\')\n                                    else:\n                                        decoded = pair[1]\n                                        decoded = decoded.replace("%3D","=")\n                                        print_err("Continuing with " + pair[0][1:] + " = " + decoded + "\\n")\n                                        modified_request_headers[pair[0][1:]] = decoded\n                                elif (instructions[i] == "sureroute"):\n                                    print_err("Adding sureroute test condition...\\n")\n                                    sureroute = 1\n                                elif (instructions[i] == "prefetch"):\n                                    print_err("Adding prefetch test condition...\\n")\n                                    prefetch = 1\n                                elif (instructions[i] == "gzip"):\n                                    print_err("Adding gzip test condition...\\n")\n                                    gzip = 1\n                                elif (instructions[i] == "nogzip"):\n                                    print_err("Adding nogzip test condition...\\n")\n                                    nogzip = 1\n                                elif (instructions[i].startswith("status=")):\n                                    pair = instructions[i].split("=")\n                                    if (len(pair) != 2):\n                                        print_err("Skipping " + instructions[i] + ", syntax must be key=value",color=\'red\')\n                                    else:\n                                        print_err("Continuing with " + pair[0] + " = " + pair[1] + "\\n")\n                                        print_err("Adding status code test condition...\\n")\n                                        status = pair[1]\n                                elif (instructions[i].startswith("cpcode=")):\n                                    pair = instructions[i].split("=")\n                                    if (len(pair) != 2):\n                                        print_err("Skipping " + instructions[i] + ", syntax must be key=value",color=\'red\')\n                                    else:\n                                        print_err("Continuing with " + pair[0] + " = " + pair[1] + "\\n")\n                                        print_err("Adding cp code code test condition...\\n")\n                                        cpcode = pair[1]\n                                elif (instructions[i].startswith("redirect=")):\n                                    pair = instructions[i].split("=")\n                                    if (len(pair) != 2):\n                                        print_err("Skipping " + instructions[i] + ", syntax must be key=value",color=\'red\')\n                                    else:\n                                        print_err("Continuing with " + pair[0] + " = " + pair[1] + "\\n")\n                                        print_err("Adding redirect test condition...\\n")\n                                        redirect_pair = pair[1].split(",")\n                                        if (len(redirect_pair) != 2):\n                                            print_err("Skipping " + instructions[i] + ", syntax must be status,location",color=\'red\')\n                                        else:\n                                            redirect_status = redirect_pair[0]\n                                            redirect_location = redirect_pair[1]\n                                elif (instructions[i].startswith("cache=")):\n                                    pair = instructions[i].split("=")\n                                    if (len(pair) != 2):\n                                        print_err("Skipping " + instructions[i] + ", syntax must be key=value",color=\'red\')\n                                    else:\n                                        print_err("Continuing with " + pair[0] + " = " + pair[1] + "\\n")\n                                        print_err("Adding cache test condition...\\n")\n                                        cache_pair = pair[1].split(",")\n                                        if (len(cache_pair) != 2):\n                                            print_err("Skipping " + instructions[i] + ", syntax must be duration,interval",color=\'red\')\n                                        else:\n                                            cache_duration = cache_pair[0]\n                                            cache_interval = cache_pair[1]\n                                elif (instructions[i] == "nostore"):\n                                    print_err("Adding nostore test condition...\\n")\n                                    nostore = 1\n                                elif (instructions[i] == "bypass"):\n                                    print_err("Adding bypass test condition...\\n")\n                                    bypass = 1\n                                elif (instructions[i].startswith("var=")):\n                                    pair = instructions[i].split("=")\n                                    if (len(pair) != 2):\n                                        print_err("Skipping " + instructions[i] + ", syntax must be key=value",color=\'red\')\n                                    else:\n                                        print_err("Continuing with " + pair[0] + " = " + pair[1] + "\\n")\n                                        print_err("Adding variable test condition...\\n")\n                                        var_pair = pair[1].split("|")\n                                        if (len(var_pair) != 2):\n                                            print_err("Skipping " + instructions[i] + ", syntax must be name|value",color=\'red\')\n                                        else:\n                                            varis[var_pair[0]] = var_pair[1]\n                                elif (instructions[i].startswith("keycontains=")):\n                                    pair = instructions[i].split("=")\n                                    if (len(pair) != 2):\n                                        print_err("Skipping " + instructions[i] + ", syntax must be key=value",color=\'red\')\n                                    else:\n                                        print_err("Continuing with " + pair[0] + " = " + pair[1] + "\\n")\n                                        print_err("Adding keycontains test condition...\\n")\n                                        keycontains.append(pair[1])\n                                elif (instructions[i].startswith("keyomits=")):\n                                    pair = instructions[i].split("=")\n                                    if (len(pair) != 2):\n                                        print_err("Skipping " + instructions[i] + ", syntax must be key=value",color=\'red\')\n                                    else:\n                                        print_err("Continuing with " + pair[0] + " = " + pair[1] + "\\n")\n                                        print_err("Adding keyomits test condition...\\n")\n                                        keyomits.append(pair[1])\n                                elif (instructions[i] == "excludequery"):\n                                    print_err("Adding excludequery test condition...\\n")\n                                    excludequery = 1\n                                elif (instructions[i].startswith("headeris=")):\n                                    pair = instructions[i].split("=")\n                                    if (len(pair) != 2):\n                                        print_err("Skipping " + instructions[i] + ", syntax must be key=value",color=\'red\')\n                                    else:\n                                        print_err("Continuing with " + pair[0] + " = " + pair[1] + "\\n")\n                                        print_err("Adding headeris test condition...\\n")\n                                        header_pair = pair[1].split("|")\n                                        if (len(header_pair) != 2):\n                                            print_err("Skipping " + instructions[i] + ", syntax must be key|value",color=\'red\')\n                                        else:\n                                            headeris[header_pair[0]] = header_pair[1]\n                                elif (instructions[i].startswith("novarval=")):\n                                    pair = instructions[i].split("=")\n                                    if (len(pair) != 2):\n                                        print_err("Skipping " + instructions[i] + ", syntax must be key=value",color=\'red\')\n                                    else:\n                                        print_err("Continuing with " + pair[0] + " = " + pair[1] + "\\n")\n                                        print_err("Adding novarval test condition...\\n")\n                                        novarval.append(pair[1])\n                                elif (instructions[i].startswith("novar=")):\n                                    pair = instructions[i].split("=")\n                                    if (len(pair) != 2):\n                                        print_err("Skipping " + instructions[i] + ", syntax must be key=value",color=\'red\')\n                                    else:\n                                        print_err("Continuing with " + pair[0] + " = " + pair[1] + "\\n")\n                                        print_err("Adding novar test condition...\\n")\n                                        novar.append(pair[1])\n                                elif (instructions[i].startswith("noheader=")):\n                                    pair = instructions[i].split("=")\n                                    if (len(pair) != 2):\n                                        print_err("Skipping " + instructions[i] + ", syntax must be key=value",color=\'red\')\n                                    else:\n                                        print_err("Continuing with " + pair[0] + " = " + pair[1] + "\\n")\n                                        print_err("Adding noheader test condition...\\n")\n                                        noheader.append(pair[1])\n                                elif (instructions[i].startswith("dolog=")):\n                                    pair = instructions[i].split("=")\n                                    if (len(pair) != 2):\n                                        print_err("Skipping " + instructions[i] + ", syntax must be key=value",color=\'red\')\n                                    else:\n                                        reject = None\n                                        if (pair[1].startswith("cookies")):\n                                            cookie_pair = pair[1].split("|")\n                                            if (len(cookie_pair) != 2):\n                                                print_err("Rejecting " + instructions[i] + ", syntax must be dolog=cookies|NAME")\n                                                reject = 1\n                                        if (reject == None):\n                                            print_err("Continuing with " + pair[0] + " = " + pair[1] + "\\n")\n                                            print_err("Adding dolog test condition...\\n")\n                                            dolog.append(pair[1])\n                                elif (instructions[i].startswith("nolog=")):\n                                    pair = instructions[i].split("=")\n                                    if (len(pair) != 2):\n                                        print_err("Skipping " + instructions[i] + ", syntax must be key=value",color=\'red\')\n                                    else:\n                                        print_err("Continuing with " + pair[0] + " = " + pair[1] + "\\n")\n                                        print_err("Adding nolog test condition...\\n")\n                                        nolog.append(pair[1])\n                                elif (instructions[i].startswith("secpolicy=")):\n                                    pair = instructions[i].split("=")\n                                    if (len(pair) != 2):\n                                        print_err("Skipping " + instructions[i] + ", syntax must be key=value",color=\'red\')\n                                    else:\n                                        print_err("Continuing with " + pair[0] + " = " + pair[1] + "\\n")\n                                        print_err("Adding security policy name code test condition...\\n")\n                                        secpolicy = pair[1]\n                                elif (instructions[i] == "notd"):\n                                    print_err("Adding notd test condition...\\n")\n                                    notd = 1\n                                else:\n                                    print_err("Skipping unknown instruction: " + instructions[i] + "\\n",color=\'red\')\n\n                            print_err("Tokens processed\\n")\n                            print_err("Generating test request: " + url + "\\n")\n                            #generate test requests\n                            postarray = []\n\n                            formatted_added_request_headers = ""\n                            if (len(added_request_headers) >= 1):\n                                position = 0\n                                for header in added_request_headers:\n                                    position = position + 1\n                                    if (position > 1):\n                                        formatted_added_request_headers = formatted_added_request_headers + ","\n                                    formatted_added_request_headers = formatted_added_request_headers + f"""\n                                        {{\n                                            "headerName": "{header}",\n                                            "headerValue": "{added_request_headers[header]}",\n                                            "headerAction": "add"\n                                        }}\n                                    """\n\n                            formatted_modified_request_headers = ""\n                            if (len(modified_request_headers) >= 1):\n                                position = 0\n                                for header in modified_request_headers:\n                                    position = position + 1\n                                    if (position > 1):\n                                        formatted_modified_request_headers = formatted_modified_request_headers + ","\n                                    formatted_modified_request_headers = formatted_modified_request_headers + f"""\n                                        {{\n                                            "headerName": "{header}",\n                                            "headerValue": "{modified_request_headers[header]}",\n                                            "headerAction": "modify"\n                                        }}\n                                    """\n\n                            if (formatted_added_request_headers != "" or formatted_modified_request_headers != ""):\n                                formatted_added_request_headers = ""","requestHeaders": [""" + formatted_added_request_headers\n                                formatted_modified_request_headers = formatted_modified_request_headers + """]"""\n\n                            #FIXME this code is uglier than ugly\n                            if ((formatted_added_request_headers != ""","requestHeaders": [""" and formatted_modified_request_headers != "]") and ((formatted_added_request_headers+formatted_modified_request_headers) != "")):\n                                formatted_added_request_headers = formatted_added_request_headers + ","\n\n                            postjson = f"""\n                                {{\n                                    "testRequestUrl": "{url}",\n                                    "tags": [\n                                        "goatc"\n                                    ]\n                                    {formatted_added_request_headers}\n                                    {formatted_modified_request_headers}\n                                }}\n                            """\n\n                            postarray.append(json.loads(postjson))\n                            parameters = {\'accountSwitchKey\': get_api_client().current_switchkey\n                                          }\n\n                            json_data = get_api_client().httpCaller.postAcceptingJSON(\'/test-management/v2/functional/test-requests\',\n                                                                          parameters, postarray)\n                            requestid = None\n                            try:\n                                requestid = str(json_data["failures"][0]["existingEntities"][0]["testRequestId"])\n                                print_err("Request id success!\\n")\n                            except:\n                                try:\n                                    print_err(str(json_data["successes"][0]["testRequestId"]))\n                                    requestid = str(json_data["successes"][0]["testRequestId"])\n                                    print_err("Request id success!\\n")\n                                except:\n                                    print_err("Failed to verify successfully created test id",color=\'red\')\n                            if (requestid != None):\n                                print_err("Request id is " + requestid + "\\n")\n                                caseids = []\n\n                                #status code condition and case\n                                if (status != None):\n                                    print_err("Generating status code test condition, status == " + status + "\\n")\n                                    pattern_RESPONSE_STATUS = "{\\"conditionNodeId\\": 1, \\"values\\": [\\"response_code\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 2, \\"values\\": [\\"is_one_of\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 3, \\"values\\": [" + status + "]}}}"\n                                    postjson = f"{{ \\"condition\\": {pattern_RESPONSE_STATUS} }}"\n\n                                    create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #cp code condition and case\n                                if (cpcode != None):\n                                    print_err("Generating cp code test condition, cpcode == " + cpcode + "\\n")\n                                    pattern_CPCODE = "{\\"conditionNodeId\\": 1, \\"values\\": [\\"cp_code\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 23, \\"values\\": [\\"is\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 9, \\"values\\": [" + cpcode + "]}}}"\n                                    postjson = f"{{ \\"condition\\": {pattern_CPCODE} }}"\n\n                                    create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #sureroute condition and case\n                                if (sureroute != None):\n                                    print_err("Generating sureroute test condition, sureroute is enabled\\n")\n                                    pattern_SUREROUTE = "{\\"conditionNodeId\\": 1, \\"values\\": [\\"sure_route\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 14, \\"values\\": [\\"is_enabled\\"]}}"\n                                    postjson = f"{{ \\"condition\\": {pattern_SUREROUTE} }}"\n\n                                    create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #prefetch condition and case\n                                if (prefetch != None):\n                                    print_err("Generating prefetch test condition, prefetch is enabled\\n")\n                                    pattern_PREFETCH = "{\\"conditionNodeId\\": 1, \\"values\\": [\\"prefetch_objects\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 20, \\"values\\": [\\"is_triggered\\"]}}"\n                                    postjson = f"{{ \\"condition\\": {pattern_PREFETCH} }}"\n\n                                    create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #redirect condition and case\n                                if (redirect_status != None):\n                                    decoded = redirect_location\n                                    decoded = decoded.replace("%3D", "=")\n\n                                    print_err("Generating redirect test condition, redirect_status == " + redirect_status + ", redirect_location == " + decoded + "\\n")\n                                    pattern_REDIRECT = "{\\"conditionNodeId\\": 1,\\"values\\": [\\"redirect\\"],\\"conditionNode\\": {\\"conditionNodeId\\": 2,\\"values\\": [\\"is_one_of\\"],\\"conditionNode\\": {\\"conditionNodeId\\": 13,\\"values\\": [" + redirect_status + "],\\"conditionNode\\": {\\"conditionNodeId\\": 18,\\"values\\": [\\"location\\"],\\"conditionNode\\": {\\"conditionNodeId\\": 23,\\"values\\": [\\"is\\" ],\\"conditionNode\\": {\\"conditionNodeId\\": 4,\\"values\\": [\\"" + decoded + "\\"], \\"conditionNode\\": null }}}}}}"\n                                    postjson = f"{{ \\"condition\\": {pattern_REDIRECT} }}"\n\n                                    create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #gzip condition and case\n                                if (gzip != None):\n                                    print_err("Generating gzip test condition, response is gzipped\\n")\n                                    pattern_GZIP = "{\\"conditionNodeId\\": 1, \\"values\\": [\\"last_mile_acceleration\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 22, \\"values\\": [\\"is_gzipped\\"]}}"\n                                    postjson = f"{{ \\"condition\\": {pattern_GZIP} }}"\n\n                                    create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #nozip condition and case\n                                if (nogzip != None):\n                                    print_err("Generating nogzip test condition, response is not gzipped\\n")\n                                    pattern_GZIP = "{\\"conditionNodeId\\": 1, \\"values\\": [\\"last_mile_acceleration\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 22, \\"values\\": [\\"is_not_gzipped\\"]}}"\n                                    postjson = f"{{ \\"condition\\": {pattern_GZIP} }}"\n\n                                    create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #cache condition and case\n                                if (cache_duration != None):\n                                    print_err("Generating cache test condition, cache_duration == " + cache_duration + ", cache_interval == " + cache_interval + "\\n")\n                                    pattern_CACHE = "{\\"conditionNodeId\\": 1, \\"values\\": [\\"caching_option\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 23, \\"values\\": [\\"is\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 10, \\"values\\": [\\"cache\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 11, \\"values\\": [\\"" + cache_interval + "\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 9, \\"values\\": [" + cache_duration + "]}}}}}"\n                                    postjson = f"{{ \\"condition\\": {pattern_CACHE} }}"\n\n                                    create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #nostore condition and case\n                                if (nostore != None):\n                                    print_err("Generating nostore test condition, cache is nostore\\n")\n                                    pattern_NO_STORE = "{\\"conditionNodeId\\": 1, \\"values\\": [\\"caching_option\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 23, \\"values\\": [\\"is\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 10, \\"values\\": [\\"no-store\\"]}}}"\n                                    postjson = f"{{ \\"condition\\": {pattern_NO_STORE} }}"\n\n                                    create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #bypass condition and case\n                                if (bypass != None):\n                                    print_err("Generating bypass test condition, cache is bypass\\n")\n                                    pattern_BYPASS = "{\\"conditionNodeId\\": 1, \\"values\\": [\\"caching_option\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 23, \\"values\\": [\\"is\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 10, \\"values\\": [\\"bypass-cache\\"]}}}"\n                                    postjson = f"{{ \\"condition\\": {pattern_BYPASS} }}"\n\n                                    create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #var condition and case\n                                if (len(varis) > 0):\n                                    for var in varis:\n\n                                        decoded = varis[var]\n                                        decoded = decoded.replace("%3D","=")\n                                        print_err("Generating varis test conditions, var " + var + " == " + decoded + "\\n")\n\n                                        pattern_VAR = "{\\"conditionNodeId\\": 1, \\"values\\": [\\"variable\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 4, \\"values\\": [\\"" + var + "\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 5, \\"values\\": [\\"has_a_value\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 7, \\"values\\": [\\"equals\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 4, \\"values\\": [\\"" + decoded + "\\"]}}}}}"\n                                        postjson = f"{{ \\"condition\\": {pattern_VAR} }}"\n\n                                        create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #keycontains condition and case\n                                if (len(keycontains) > 0):\n                                    for ckey in keycontains:\n\n                                        decoded = ckey\n                                        decoded = decoded.replace("%3D", "=")\n\n                                        print_err("Generating keycontains test condition, keycontains == " + ckey + "\\n")\n                                        pattern_KEYCONTAINS = "{\\"conditionNodeId\\": 1, \\"values\\": [\\"response_header\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 4, \\"values\\": [\\"X-Cache-Key\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 5, \\"values\\": [\\"has_a_value\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 7, \\"values\\": [\\"contains\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 4, \\"values\\": [\\"" + decoded + "\\"]}}}}}"\n                                        postjson = f"{{ \\"condition\\": {pattern_KEYCONTAINS} }}"\n\n                                        create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #keyomits condition and case\n                                if (len(keyomits) > 0):\n                                    for ckey in keyomits:\n\n                                        decoded = ckey\n                                        decoded = decoded.replace("%3D", "=")\n\n                                        print_err("Generating keyomits test condition, keyomits == " + ckey + "\\n")\n                                        pattern_KEYOMITS = "{\\"conditionNodeId\\": 1, \\"values\\": [\\"response_header\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 4, \\"values\\": [\\"X-Cache-Key\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 5, \\"values\\": [\\"has_a_value\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 7, \\"values\\": [\\"does_not_contain\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 4, \\"values\\": [\\"" + decoded + "\\"]}}}}}"\n                                        postjson = f"{{ \\"condition\\": {pattern_KEYOMITS} }}"\n\n                                        create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #excludequery condition and case\n                                if (excludequery != None):\n                                    print_err("Generating excludequery test condition\\n")\n                                    pattern_EXCLUDEQUERY = "{\\"conditionNodeId\\": 1, \\"values\\": [\\"cache_key_query_parameters\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 19, \\"values\\": [\\"not_included\\"]}}"\n                                    postjson = f"{{ \\"condition\\": {pattern_EXCLUDEQUERY} }}"\n\n                                    create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #headeris condition and case\n                                if (len(headeris) > 0):\n                                    for header in headeris:\n\n                                        decoded = headeris[header]\n                                        decoded = decoded.replace("%3D","=")\n\n                                        print_err("Generating headeris test conditions, header " + header + " == " + decoded + "\\n")\n                                        pattern_KEYCONTAINS = "{\\"conditionNodeId\\": 1, \\"values\\": [\\"response_header\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 4, \\"values\\": [\\""+header+"\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 5, \\"values\\": [\\"has_a_value\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 7, \\"values\\": [\\"equals\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 4, \\"values\\": [\\"" + decoded + "\\"]}}}}}"\n                                        postjson = f"{{ \\"condition\\": {pattern_KEYCONTAINS} }}"\n\n                                        create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #novarval condition and case\n                                if (len(novarval) > 0):\n                                    for nvar in novarval:\n                                        print_err("Generating novarval test condition, novarval == " + nvar + "\\n")\n                                        pattern_NOVARVAL = "{\\"conditionNodeId\\": 1, \\"values\\": [\\"variable\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 4, \\"values\\": [\\"" + nvar + "\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 5, \\"values\\": [\\"has_no_value\\"]}}}"\n                                        postjson = f"{{ \\"condition\\": {pattern_NOVARVAL} }}"\n\n                                        create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #novar condition and case\n                                if (len(novar) > 0):\n                                    for nvar in novar:\n                                        print_err("Generating novar test condition, novarval == " + nvar + "\\n")\n                                        pattern_NOVAR = "{\\"conditionNodeId\\": 1, \\"values\\": [\\"variable\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 4, \\"values\\": [\\"" + nvar + "\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 5, \\"values\\": [\\"does_not_exist\\"]}}}"\n                                        postjson = f"{{ \\"condition\\": {pattern_NOVAR} }}"\n\n                                        create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #noheader condition and case\n                                if (len(noheader) > 0):\n                                    for nheader in noheader:\n                                        print_err("Generating noheader test condition, noheader == " + nheader + "\\n")\n                                        pattern_NOHEADER = "{\\"conditionNodeId\\": 1, \\"values\\": [\\"response_header\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 4, \\"values\\": [\\"" + nheader + "\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 5, \\"values\\": [\\"does_not_exist\\"]}}}"\n                                        postjson = f"{{ \\"condition\\": {pattern_NOHEADER} }}"\n\n                                        create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #dolog condition and case\n                                if (len(dolog) > 0):\n                                    for log in dolog:\n                                        print_err("Generating dolog test condition, dolog == " + log + "\\n")\n\n                                        if (log.startswith("cookies")):\n                                            log_pair = log.split("|")\n                                            pattern_DOLOG = "{\\"conditionNodeId\\": 1,\\"values\\": [\\"log_request_details\\"],\\"conditionNode\\": {\\"conditionNodeId\\": 15,\\"values\\": [\\"cookies\\"],\\"conditionNode\\": {\\"conditionNodeId\\": 24,\\"values\\": [\\"logged\\"],\\"conditionNode\\": {\\"conditionNodeId\\": 17,\\"values\\": [\\""+log_pair[1]+"\\"]}}}}"\n                                            postjson = f"{{ \\"condition\\": {pattern_DOLOG} }}"\n                                        else:\n                                            pattern_DOLOG = "{\\"conditionNodeId\\": 1,\\"values\\": [\\"log_request_details\\"],\\"conditionNode\\": {\\"conditionNodeId\\": 15,\\"values\\": [\\"" + log + "\\"],\\"conditionNode\\": {\\"conditionNodeId\\": 16,\\"values\\": [\\"is_logged\\"]}}}"\n                                            postjson = f"{{ \\"condition\\": {pattern_DOLOG} }}"\n\n                                        create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #dolog condition and case\n                                if (len(nolog) > 0):\n                                    for log in nolog:\n                                        print_err("Generating nolog test condition, nolog == " + log + "\\n")\n                                        if (log == "cookies"):\n                                            pattern_NOLOG = "{\\"conditionNodeId\\": 1,\\"values\\": [\\"log_request_details\\"],\\"conditionNode\\": {\\"conditionNodeId\\": 15,\\"values\\": [\\"" + log + "\\"],\\"conditionNode\\": {\\"conditionNodeId\\": 24,\\"values\\": [\\"not_logged\\"]}}}"\n                                        else:\n                                            pattern_NOLOG = "{\\"conditionNodeId\\": 1,\\"values\\": [\\"log_request_details\\"],\\"conditionNode\\": {\\"conditionNodeId\\": 15,\\"values\\": [\\"" + log + "\\"],\\"conditionNode\\": {\\"conditionNodeId\\": 16,\\"values\\": [\\"is_not_logged\\"]}}}"\n                                        postjson = f"{{ \\"condition\\": {pattern_NOLOG} }}"\n\n                                        create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #sec policy condition and case\n                                if (secpolicy != None):\n                                    print_err("Generating secpolicy test condition, secpolicy == " + secpolicy + "\\n")\n                                    pattern_SECPOLICY = "{\\"conditionNodeId\\": 1, \\"values\\": [\\"policy_name\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 23, \\"values\\": [\\"is\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 4, \\"values\\": [\\"" + secpolicy + "\\"]}}}"\n                                    postjson = f"{{ \\"condition\\": {pattern_SECPOLICY} }}"\n\n                                    create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #notd condition and case\n                                if (notd != None):\n                                    print_err("Generating notd test condition, tiered dist is not enabled\\n")\n                                    pattern_NOTD = "{\\"conditionNodeId\\": 1, \\"values\\": [\\"tiered_distribution\\"], \\"conditionNode\\": {\\"conditionNodeId\\": 14, \\"values\\": [\\"is_not_enabled\\"]}}"\n                                    postjson = f"{{ \\"condition\\": {pattern_NOTD} }}"\n\n                                    create_test_condition(profiles_data, caseids, requestid, postjson)\n\n                                #conditions and cases done\n                                suiteids = []\n                                for case in caseids:\n                                    suiteids.append(case)\n                                if (len(suiteids) > 0):\n                                    parameters = {\'accountSwitchKey\': get_api_client().current_switchkey\n                                                  }\n                                    addcases = get_api_client().httpCaller.postAcceptingJSON(f\'/test-management/v2/functional/test-suites/{newid}/associations/test-cases/associate\',\n                                                                                  parameters, suiteids)\n\n                                    print_err("Results of test case association:\\n")\n                                    print_err(get_api_client().get_last_endpoint_result().json());\n                                    time.sleep(.5)\n\n                                else:\n                                    print_err("No valid test cases found in script, none will be generated.")\n                            else:\n                                pprint.pprint(json_data)\n            return testscripts\n\n    print_err("No test scripts found, none executed.")\n    return None\n\ndef docmd_LIST_GOATC_TEST_SUITES():\n    reject_blank_switchkey()\n    parameters = {\'accountSwitchKey\': get_api_client().current_switchkey}\n\n    json_data = get_api_client().httpCaller.getJSONResult(\'/test-management/v2/functional/test-suites?includeRecentlyDeleted=false\', parameters)\n    listme = []\n    if (get_api_client().get_last_response_code() == 200):\n        for item in json_data:\n            for key in item.keys():\n                if (key == "testSuiteDescription"):\n                    if (item[key] == \'This test suite was automatically generated by the goatc script.\'):\n                        listme.append(item)\n        pprint.pprint(listme)\n        return listme\n\n    print_err("Could not retrieve list of test suites.\\nStatus code: ")\n    print_err(get_api_client().get_last_response_code())\n    print_err("\\nJSON response body:")\n    print_err(get_api_client().get_last_endpoint_result().json());\n    return json_data\n\ndef docmd_REMOVE_GOATC_TEST_SUITES():\n    parameters = {\'accountSwitchKey\': get_api_client().current_switchkey}\n\n    json_data = get_api_client().httpCaller.getJSONResult(\'/test-management/v2/functional/test-suites?includeRecentlyDeleted=false\', parameters)\n    listme = []\n    if (get_api_client().get_last_response_code() == 200):\n        for item in json_data:\n            for key in item.keys():\n                if (key == "testSuiteDescription"):\n                    if (item[key] == \'This test suite was automatically generated by the goatc script.\'):\n                        listme.append(item)\n        for item in listme:\n            json_data = get_api_client().httpCaller.deleteAcceptingJSON(\n                f\'/test-management/v2/functional/test-suites/{item["testSuiteId"]}?deleteChildResources=false\', parameters)\n            pprint.pprint(json_data)\n        return listme\n\n    print_err("Could not retrieve list of test suites.\\nStatus code: ")\n    print_err(get_api_client().get_last_response_code())\n    print_err("\\nJSON response body:")\n    print_err(get_api_client().get_last_endpoint_result().json());\n    return json_data\n\ndef addargs_SHOW_GOATC_UI():\n    get_input_args().parser.add_argument("--groupId", required=False, help="groupId", action="store", dest="groupid", default="")\n    get_input_args().parser.add_argument("--contractId", required=False, help="contractId", action="store", dest="contractid", default="")\n    get_input_args().parser.add_argument("--propertyId", required=False, help="propertyId", action="store", dest="propertyid", default="")\n    get_input_args().parser.add_argument("--versionId", required=False, help="versionId", action="store", dest="versionid", default="")\n    get_input_args().parser.add_argument("--testSuiteName", required=False, help="testSuiteName", action="store", dest="testsuitename", default="")\n\ndef docmd_SHOW_GOATC_UI():\n    contractId = get_input_args().args.contractid\n    groupId = get_input_args().args.groupid\n    propertyId = get_input_args().args.propertyid\n    versionId = get_input_args().args.versionid\n    testSuiteName = get_input_args().args.testsuitename\n    gui.showme()')
    #!/usr/bin/env python3
    
    '''
    goatc v0.1a
    
    Detailed Description:
    Primary purpose of this script:
    generate ATC test cases from scripts stored in the rule Notes fields of the configuration to be tested, and associate them to a test suite.
    
    example usage:
    ./goatc.py --cmd EXECUTE_PROPERTY_ATC_SCRIPTS --switchKey B-3-U3XNPI --contractId 3-U3Y8U4 --groupId 62925 --propertyId 408901 --version 3 --testSuiteName breaktheinternet.scoe-sil.net.xml-v3
    
    Regression test scripts should be pasted into the Notes field of the configuration, and have the following syntax:
    ATC![METHOD]@[URL]#[keyword1]#[keyword2]#[keywordetc]@
    
    Example test script #1: status code = 200, netstorage cache key, query parameters excluded:
    ATC!GET@https://breaktheinternet.scoe-sil.net/200.html#status=200#keycontains=/scoesil.download.akamai.com/#excludequery@
    
    Example test script group #2: siteFailover=true sets cookie properly, and siteFailover cookie correctly breaks forward connection
    ATC!GET@https://breaktheinternet.scoe-sil.net/failoverTest/?siteFailover=true#redirect=302,https://breaktheinternet.scoe-sil.net/failoverTest/#headeris=Set-Cookie|siteFailover%3Dtrue; secure; HttpOnly@
    ATC!GET@https://breaktheinternet.scoe-sil.net/failoverTest/#^Cookie=siteFailover%3Dtrue;#status=503@
    
    For a very good example of a comprehensive set of test scripts, see configuration:
    prod-ssl-mchb.hrsa.gov.xml v42
    
    Currently Supported keywords:
    pragmas
    Description: add basic pragma headers to request
    
    ^[headerName]=[headerValue]
    Description: add request header [headerName] to request with [headerValue]
    
    ~[headerName]=[headerValue]
    Description: modify existing request header [headerName] and use [headerValue] instead.
    
    sureroute
    Description: test if sureroute was triggered by request
    
    prefetch
    Description: test if prefetching was triggered by request.
    
    gzip
    Description: test if response was gzipped
    
    nogzip
    Description: test if response was NOT gzipped
    
    status=[STATUS]
    Description: test if response status code equals [STATUS]
    
    cpcode=[CPCODE]
    Description: test if cp code of request equals [CPCODE]
    
    redirect=[STATUS],[LOCATION]
    Description: confirm response was a redirect with specified STATUS and LOCATION values.
    
    cache=[DURATION],[INTERVAL]
    Description: confirm cache TTL is expcted DURATION and INTERVAL
    
    nostore
    Description: confirm cache TTL is nostore
    
    var=[NAME]|[VALUE]
    Description: confirm variable was set with given [NAME] and [VALUE]
    
    keycontains=[STRING]
    Description: confirm X-Cache-Key header contains [STRING]
    
    keyomits=[STRING]
    Description: confirm X-Cache-Key header does not contain [STRING]
    
    excludequery
    Description: confirm query parametere are excluded from cache key.
    
    headeris=[HEADERNAME]|[HEADERVALUE]
    Description: confirm response header [HEADERNAME] has value [HEADERVALUE]
    
    novarval=[VARNAME]
    Description: confirm variable [VARNAME] exists and has no value.
    
    novar=[VARNAME]
    Description: confirm variable [VARNAME] does not exist.
    
    noheader=[HEADERNAME]
    Description: confirm response header [HEADERNAME] does not exist.
    
    dolog=[DATATYPE]
    Description: confirm [DATATYPE] will be logged.  Currently supported datatypes:
    accept_language_header
    host_header
    custom_data
    referrer_header
    user_agent_header
    cookies|[COOKIENAME]
    
    nolog=[DATATYPE]
    Description: confirm [DATATYPE] will NOT be logged.  Currently supported datatypes:
    accept_language_header
    host_header
    custom_data
    referrer_header
    user_agent_header
    cookies
    
    secpolicy=[POLICY NAME]
    Description: confirm security policy named [POLICY NAME] applied to the request.
    
    Secondary purpose of this script:
    quick implementation of arbitrary API functions. See "supported_commands" list for available commands.
    '''
    
    import util, pprint, commands
    
    #initialize main python module
    debugmsg = util.print_err
    die = util.die
    util.set_default_verbosity(1)
    hashlib_seed = 'goATC'
    api_client = None
    
    #error codes and messages; use only 0 or positive integers.
    err_success = [0,"Success"]
    err_unexplained_failure = [1,"Unexplained failure."]
    err_bad_status_code = [2,"Bad status code returned"]
    err_invalid_command = [3,"Invalid command."]
    
    #index of commands supported by this script
    supported_commands = [
        ["ACCOUNT_NAME",
         "Simply lookup and print the account name for the supplied switchKey."],
        ["ACCOUNT_CONTRACTS",
         "List the contracts associated with the supplied switchKey."],
        ["ACCOUNT_GROUPS",
         "List the configurations associated with the supplied switchKey."],
        ["ACCOUNT_PROPERTIES",
         "List the configurations associated with the supplied switchKey, contract, and group."],
        ["PROPERTY_HOSTNAMES",
         "Download list of hostnames."],
        ["PROPERTY_XML",
         "Download configuration metadata as XML."],
        ["PROPERTY_JSON",
         "Download configuration metadata as JSON."],
        ["PROPERTY_RULES_JSON",
         "Download configuration version metadata as JSON."],
        ["GET_TEST_CATALOG_TEMPLATE",
         "Download the ATC test catalog template"],
        ["EXECUTE_PROPERTY_ATC_SCRIPTS",
         "Download the list of ATC test scripts saved to the comments of given property version and execute them.  For the experimental GUI version, supplly the --ui argument.  To supply test script from a local file, supply --localFile /path/to/file."],
        ["LIST_GOATC_TEST_SUITES",
         "Download the list of ATC test suites that were automatically generated by this script."],
        ["REMOVE_GOATC_TEST_SUITES",
         "Remove the ATC test suites that were automatically generated by this script."],
        ["SHOW_GOATC_UI",
         "Show experimental GUI for parameterizing this script."]
    ]
    current_command_index = -1
    
    def initialize_arguments():
        #add builtin library arguments
        args = util.ApiArguments(__doc__, autoparse=False)
    
        #generate help text for supported commands
        cmd_list = ""
        for pair in supported_commands:
            if (cmd_list != ""):
                cmd_list = cmd_list + ", "
            cmd_list = cmd_list + pair[0]
        args.required_args.add_argument("--cmd", required=False,
                                             help="supported commands: " + cmd_list,
                                             action="store", dest="command", default="SHOW_GOATC_UI")
    
        #parse arguments
        args.parse_args()
    
        #make sure command entered is valid
        valid_command = 0
        global current_command_index
        for pair in supported_commands:
            current_command_index = current_command_index + 1
            if args.args.command.lower() == pair[0].lower():
                valid_command = 1
                break
        if (valid_command == 0):
            die(err_invalid_command[0],args.args.command + " is not a valid command.  Valid commands are: " + cmd_list)
    
        return args
    
    if __name__ == "__main__":
        try:
            util.set_input_args(initialize_arguments())
    
            if (util.get_input_args().args.explain):
                print("Explanation for the " + supported_commands[current_command_index][0] + " command: \n\n" + supported_commands[current_command_index][1])
            else:
                util.set_api_client(util.ApiClient(switchkey=util.get_input_args().switchkey, edgerc=util.get_input_args().edgerc, section=util.get_input_args().section))
                arg_fname = "addargs_" + supported_commands[current_command_index][0];
                if (hasattr(commands, arg_fname)):
                    f = getattr(commands, arg_fname)
                    f()
                    util.get_input_args().parse_args()
                fname = "docmd_" + supported_commands[current_command_index][0];
                f = getattr(commands, fname)
                f()
    
        finally:
            util.cleanup()
    